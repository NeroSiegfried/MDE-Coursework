GRAMMAR:


grammar uk.ac.kcl.in.nerosiegfried.chessdsl.ChessDSL with org.eclipse.xtext.common.Terminals

generate chessDSL "http://www.ac.uk/kcl/in/nerosiegfried/chessdsl/ChessDSL"



Model:

	game=Game

;



Game:

	'Game' title=STRING

	('Players:' players+=Player+)?

	(initial=InitialState)?

	'Moves:' moves+=MovePair*

	'end'

	(conclusion=Conclusion)?

;



Player:

	color=Color ':' name=STRING

;



InitialState:

	{InitialState}

	'InitialState' ('fresh' | 'custom' positions=CustomPositions)?

;



CustomPositions:

	{CustomPositions}

	'Positions:' '{'

		(placement+=Placement)*

	'}'

;



Placement:

	//e.g., "WhiteKing on e1" or "BlackPawn = a7"

	piece=CustomPiece ('=' | 'on') square=Square

;



CustomPiece:

	(color=Color)

	(kind=Piece)

;



MovePair:

	//whiteMove can also be '...' when Black plays first in the position

	//or from where the records start. blackMove is optional depending on

	//where the records end or how the game itself ends

	moveNumber=MOVENUMBER

	(((color1=[Player])? whiteMove=AnyMove )| "...")

	((color2=[Player])?blackMove=AnyMove)?

;



MOVENUMBER hidden():

	INT "."

;



AnyMove:

	//for possible extensions to the language

	move=DSLMove ('(' remarks+=Remark* ')')?

;



DSLMove:

	Move | Capture | Castle | EnPassant | Promotion | Dummy

;



Dummy:
	{Dummy}
	'dummy'

;



Move:

	//Pawn(e2 -> e4), Knight from b1 to c3, etc.

	('moves')?

	(piece=Piece)

	('(' from=Square '->' to=Square ')'|

	'from' from=Square 'to' to=Square

	)

;



Capture:

	//An extension of a regular Move

	move=Move

	(('Capture(' capture=Piece ')')|

	(('and')? 'captures' capture=Piece))

;



Castle:

	('Castle(' ('Kingside'|'Queenside') ')')|

	('castles' ('on' 'the')? ('Kingside'|'Queenside'))|

	(move=Move 'Castle()')|

	(move=Move 'and' 'castles')

;



EnPassant:

	//An extension of a Capture

	capture=Capture 'on' square=Square

;



Promotion:

	//e.g., promotes pawn to Queen on e8,

	//

	move=(Move|Capture) 'Promotion(' piece=Piece ')'

;



enum Remark:
	Good |

	Bad |

	Excellent |

	Risky |

	Dubious |

	Check |

	Checkmate

;



Conclusion:

	(method=Method)? result=Result

;



Method:

	Win | Draw

;



Win:

	TimeUp | Resign | Checkmate

;





TimeUp:

	player=[Player] 'ran' 'out' 'of' 'time'

;



Resign:

	player=[Player] 'resigned'

;



Checkmate:

	player1=[Player] 'checkmated' player2=[Player]

;



Draw:

	player1=[Player] 'and' player2=[Player]

	result=(Stalemate|Threefold|Fifty|Agree)

;



Stalemate returns EString:

	'ended' 'the' 'game' 'in' 'a' 'stalemate'

;



Threefold returns EString:

	'repeated' 'a' 'position' 'three' 'times'

;



Fifty returns EString:

	'played' 'fifty' 'moves' 'without' 'a' 'capture'

;



Agree returns EString:

	'agreed' 'to' 'a' 'draw'

;



Result:

	((player=[Player]|color=Color) 'wins')|

	('draw')

;



enum Color:

	White | Black

;



enum Piece:

	King  |

	Queen |

	Rook  |

	Bishop|

	Knight|

	Pawn

;



Square:
	square=SQUARETERMINAL
;



terminal SQUARETERMINAL:
	('a'..'h'|'A'..'H')('1'..'8')

;



GENERATOR:

///**
// * generated by Xtext 2.32.0
// */
//package uk.ac.kcl.in.nerosiegfried.chessdsl.generator;
//
//import org.eclipse.emf.ecore.resource.Resource;
//import org.eclipse.xtext.generator.AbstractGenerator;
//import org.eclipse.xtext.generator.IFileSystemAccess2;
//import org.eclipse.xtext.generator.IGeneratorContext;
//
///**
// * Generates code from your model files on save.
// * 
// * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
// */
//@SuppressWarnings("all")
//public class ChessDSLGenerator extends AbstractGenerator {
//  @Override
//  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
//  }
//}


package uk.ac.kcl.in.nerosiegfried.chessdsl.generator;

import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import java.util.List;

import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.generator.IFileSystemAccess2;

import uk.ac.kcl.in.nerosiegfried.chessdsl.chessDSL.*;
import uk.ac.kcl.in.nerosiegfried.chessdsl.validation.ChessDSLValidator; // for BoardState reference or define your own

public class ChessDSLGenerator extends AbstractGenerator {

    /**
     * We’ll reuse a BoardState. In production, unify with your validator code
     * or store partial data. For demonstration, we replicate it here.
     */
    static class PieceInfo {
        public Color color; 
        public Piece type; 
        public boolean hasMoved;
        public PieceInfo(Color c, Piece t) { color=c; type=t; hasMoved=false; }
    }

    static class BoardState {
        Map<String, PieceInfo> boardMap = new HashMap<>();
        public void initFreshBoard() {
            boardMap.clear();
            place("a1",Color.WHITE,Piece.ROOK); place("b1",Color.WHITE,Piece.KNIGHT);
            place("c1",Color.WHITE,Piece.BISHOP); place("d1",Color.WHITE,Piece.QUEEN);
            place("e1",Color.WHITE,Piece.KING); place("f1",Color.WHITE,Piece.BISHOP);
            place("g1",Color.WHITE,Piece.KNIGHT); place("h1",Color.WHITE,Piece.ROOK);
            for(char c='a'; c<='h'; c++) place(c+"2",Color.WHITE,Piece.PAWN);

            place("a8",Color.BLACK,Piece.ROOK); place("b8",Color.BLACK,Piece.KNIGHT);
            place("c8",Color.BLACK,Piece.BISHOP); place("d8",Color.BLACK,Piece.QUEEN);
            place("e8",Color.BLACK,Piece.KING); place("f8",Color.BLACK,Piece.BISHOP);
            place("g8",Color.BLACK,Piece.KNIGHT); place("h8",Color.BLACK,Piece.ROOK);
            for(char c='a'; c<='h'; c++) place(c+"7",Color.BLACK,Piece.PAWN);
        }
        public void place(String sq, Color c, Piece p) {
            boardMap.put(sq, new PieceInfo(c,p));
        }
        public boolean isOccupied(String sq) {
            return boardMap.containsKey(sq);
        }
        public PieceInfo get(String sq) {
            return boardMap.get(sq);
        }
        public void remove(String sq) {
            boardMap.remove(sq);
        }
        public void movePiece(String from, String to) {
            PieceInfo pi = boardMap.remove(from);
            if(pi != null) {
                pi.hasMoved=true;
                boardMap.remove(to);
                boardMap.put(to, pi);
            }
        }
    }

    @Override
    public void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        if(resource.getContents().isEmpty() || !(resource.getContents().get(0) instanceof Model)) {
            return;
        }
        Model root = (Model) resource.getContents().get(0);
        Game game = root.getGame();
        if(game == null) return;

        BoardState board = new BoardState();
        if(game.getInitial()!=null && game.getInitial().getPositions()!=null) {
            for(Placement p: game.getInitial().getPositions().getPlacement()) {
                board.place(p.getSquare().getSquare(), 
                            p.getPiece().getColor(),
                            p.getPiece().getKind());
            }
        } else {
            board.initFreshBoard();
        }

        StringBuilder sb = new StringBuilder();
        sb.append("=== Chess Algebraic Notation ===\n");
        sb.append("Game: ").append(game.getTitle()).append("\n");

        int moveIndex=1;
        // We’ll track if first white move is "...", for special output
        for(MovePair mp: game.getMoves()) {
            // Check if the white move is "..." => means black moves first
            boolean skipWhite = ("...".equals(mp.getWhiteMove()));
            sb.append(moveIndex).append(". ");
            if(skipWhite) {
                // e.g. "1. ... e5"
                // so we only do black’s move
                if(mp.getBlackMove()!=null && mp.getBlackMove().getMove()!=null) {
                    DSLMove bmove = mp.getBlackMove().getMove();
                    String notation = toAlgebraic(board, bmove, Color.BLACK);
                    applyMove(board, bmove, Color.BLACK);
                    sb.append("... ").append(notation).append("\n");
                }
            } else {
                // White
                AnyMove aw = mp.getWhiteMove();
                if(aw!=null && aw.getMove()!=null) {
                    DSLMove wmove = aw.getMove();
                    String note = toAlgebraic(board, wmove, Color.WHITE);
                    applyMove(board, wmove, Color.WHITE);
                    sb.append(note).append(" ");
                }
                // Black
                AnyMove ab = mp.getBlackMove();
                if(ab!=null && ab.getMove()!=null) {
                    DSLMove bmove = ab.getMove();
                    String note = toAlgebraic(board, bmove, Color.BLACK);
                    applyMove(board, bmove, Color.BLACK);
                    sb.append(note).append(" ");
                }
                sb.append("\n");
            }
            moveIndex++;
        }
        // if there's a conclusion
        if(game.getConclusion()!=null) {
            sb.append("Conclusion: ").append(renderConclusion(game.getConclusion())).append("\n");
        }

        fsa.generateFile(deriveTargetFileNameFor(root,  resource), sb.toString());
    }
    
    private String deriveTargetFileNameFor(Model model, Resource resource) {
    	return resource.getURI().lastSegment();
    }

    /**
     * Convert DSLMove to standard algebraic notation. If it's a check or mate, add + or #.
     */
    private String toAlgebraic(BoardState board, DSLMove move, Color side) {
        if(move instanceof Move) {
            return basicToAlg(board,(Move)move,side);
        } else if(move instanceof Capture) {
            return captureToAlg(board,(Capture)move,side);
        } else if(move instanceof Castle) {
            return castleToAlg(board,(Castle)move,side);
        } else if(move instanceof EnPassant) {
            return enPassantToAlg(board,(EnPassant)move,side);
        } else if(move instanceof Promotion) {
            return promotionToAlg(board,(Promotion)move,side);
        } else if(move instanceof Dummy) {
            return "dummy";
        }
        return "";
    }

//    private void applyMove(BoardState board, DSLMove move, Color side) {
//        // Mirror logic from validator
//        if(move instanceof Move) {
//            Move bm=(Move)move; board.movePiece(bm.getFrom().getSquare(), bm.getTo().getSquare());
//        } else if(move instanceof Capture) {
//            Move base=((Capture)move).getMove();
//            board.movePiece(base.getFrom().getSquare(), base.getTo().getSquare());
//        } else if(move instanceof EnPassant) {
//            EnPassant em=(EnPassant)move;
//            Capture cm = em.getCapture();
//            Move base=cm.getMove();
//            board.movePiece(base.getFrom().getSquare(), base.getTo().getSquare());
//            String capturedSquare=em.getSquare().getSquare();
//            board.remove(capturedSquare);
//        } else if(move instanceof Promotion) {
//            Promotion pm=(Promotion)move;
//            DSLMove base=pm.getMove();
//            Move bm=null; boolean isCap=false;
//            if(base instanceof Move) bm=(Move)base;
//            else if(base instanceof Capture) {
//                bm=((Capture)base).getMove(); isCap=true;
//            }
//            String from=bm.getFrom().getSquare();
//            String to= bm.getTo().getSquare();
//            board.movePiece(from,to);
//            // remove occupant
//            board.remove(to);
//            // place new piece
//            board.place(to, side, pm.getPiece());
//        } else if(move instanceof Castle) {
//            Castle cm=(Castle)move;
//            String ctype = "Kingside"; // from checkCastleType
//            // we guess
//            if(side==Color.WHITE) {
//                if(ctype.equals("Kingside")) {
//                    board.remove("e1");board.remove("h1");
//                    board.place("g1", Color.WHITE, Piece.KING);
//                    board.place("f1", Color.WHITE, Piece.ROOK);
//                } else {
//                    board.remove("e1");board.remove("a1");
//                    board.place("c1", Color.WHITE, Piece.KING);
//                    board.place("d1", Color.WHITE, Piece.ROOK);
//                }
//            } else {
//                if(ctype.equals("Kingside")) {
//                    board.remove("e8");board.remove("h8");
//                    board.place("g8", Color.BLACK, Piece.KING);
//                    board.place("f8", Color.BLACK, Piece.ROOK);
//                } else {
//                    board.remove("e8");board.remove("a8");
//                    board.place("c8", Color.BLACK, Piece.KING);
//                    board.place("d8", Color.BLACK, Piece.ROOK);
//                }
//            }
//        }
//    }

    private String basicToAlg(BoardState board, Move bm, Color side) {
        Piece p = bm.getPiece();
        String from = bm.getFrom().getSquare();
        String to   = bm.getTo().getSquare();

        boolean isCheck = false, isMate=false;
        // after hypothetical move, see if it results in check or mate
        // We'll do a quick apply, then revert
        applyMove(board,bm,side);
        if(isInCheck(board, opposite(side))) {
            // if isCheckmate => '#' else '+'
            if(isCheckmate(board, opposite(side))) {
                isMate=true;
            } else {
                isCheck=true;
            }
        }
        // revert
        revertMove(board,bm,side,null);

        String pieceLetter = pieceLetter(p);
        // If it's a Pawn and no capture, omit letter
        if(p == Piece.PAWN) {
            // no occupant => no capture => check?
            if(!board.isOccupied(to)) {
                // e4
                pieceLetter = "";
            }
        }
        // no capture => no 'x'
        String note = pieceLetter;
        // For disambiguation, we assume there's no second piece. If you want disambiguation, you'd do so:
        String disamb = disambiguate(board, from, to, side, p);

        note += disamb + to; 
        if(isCheck) note += "+";
        if(isMate) note += "#";
        return note;
    }

    private String captureToAlg(BoardState board, Capture cm, Color side) {
        // e.g. Nx e4 or exd5 for pawns
        Move base = cm.getMove();
        Piece p= base.getPiece();
        String from= base.getFrom().getSquare();
        String to  = base.getTo().getSquare();
        // simulate
        boolean isCheck=false, isMate=false;
        applyMove(board,cm,side);
        if(isInCheck(board, opposite(side))) {
            if(isCheckmate(board, opposite(side))) isMate=true; 
            else isCheck=true;
        }
        revertMove(board,cm,side,null);

        String letter = pieceLetter(p);
        String disamb = disambiguate(board, from,to, side,p);
        // If it's a pawn capturing, we show the file of the from-square e.g. exd5
        if(p==Piece.PAWN) {
            letter = from.substring(0,1); // the file
        }
        String suffix = (isMate?"#": isCheck?"+":"");
        return letter + disamb + "x" + to + suffix;
    }

    private String enPassantToAlg(BoardState board, EnPassant em, Color side) {
        // exd6 e.p.
        Capture cm = em.getCapture();
        Move base = cm.getMove();
        String from= base.getFrom().getSquare();
        String to  = base.getTo().getSquare();
        boolean isCheck=false, isMate=false;
        applyMove(board,em,side);
        if(isInCheck(board, opposite(side))) {
            if(isCheckmate(board,opposite(side))) isMate=true;
            else isCheck=true;
        }
        revertMove(board,em,side,null);

        String fileFrom = from.substring(0,1);
        String suffix = isMate?"#": isCheck?"+":"";
        return fileFrom + "x" + to + " e.p." + suffix;
    }

    private String promotionToAlg(BoardState board, Promotion pm, Color side) {
        // e8=Q or exd8=Q
        DSLMove base = pm.getMove();
        Move bm=null; boolean cap=false;
        if(base instanceof Move) {
            bm=(Move)base;
        } else if(base instanceof Capture) {
            bm=((Capture)base).getMove(); 
            cap=true;
        }
        String from= bm.getFrom().getSquare();
        String to  = bm.getTo().getSquare();

        boolean isCheck=false,isMate=false;
        applyMove(board,pm,side);
        if(isInCheck(board,opposite(side))) {
            if(isCheckmate(board,opposite(side))) isMate=true;
            else isCheck=true;
        }
        revertMove(board,pm,side,null);

        // If capture => e.g. exd8=Q
        String file = (bm.getPiece()==Piece.PAWN? from.substring(0,1): pieceLetter(bm.getPiece()));
        String captureSym = cap?"x":"";
        String eq = "="+ pieceLetter(pm.getPiece());
        String suffix=(isMate?"#": isCheck?"+":"");
        if(bm.getPiece()==Piece.PAWN && !cap) {
            file=""; // just e8=Q
        }
        return file + captureSym + to + eq + suffix;
    }

    private String castleToAlg(BoardState board, Castle cm, Color side) {
        // check logic if it's O-O or O-O-O
        boolean kingside = true; // We'll guess from position or from the DSL
        // We'll do a simple check
        if(side==Color.WHITE) {
            // if board has occupant at h1 => kingside
            // if occupant at a1 => queenside
            if(board.get("h1")!=null && board.get("h1").type==Piece.ROOK) {
                kingside=true;
            } else {
                kingside=false;
            }
        } else {
            if(board.get("h8")!=null && board.get("h8").type==Piece.ROOK) {
                kingside=true;
            } else {
                kingside=false;
            }
        }
        // check or mate?
        applyMove(board,cm,side);
        boolean isCheck=false, isMate=false;
        if(isInCheck(board,opposite(side))) {
            if(isCheckmate(board,opposite(side))) isMate=true;
            else isCheck=true;
        }
        revertMove(board,cm,side,null);

        String suffix=(isMate?"#": isCheck?"+":"");
        return kingside? "O-O"+suffix : "O-O-O"+suffix;
    }

    /** 
     * Helper for disambiguation if multiple pieces of same type can go to 'to'. 
     * In real code we’d do a partial check. We do a simpler approach here. 
     */
    private String disambiguate(BoardState board, String from, String to, Color side, Piece p) {
        // skip advanced logic for brevity
        return "";
    }

    /** Apply move then revert used for check checks. Over-simplified. */
    private void applyMove(BoardState b, DSLMove m, Color side) {
        // same as doGenerate's apply
        if(m instanceof Move) {
            Move bm=(Move)m;
            b.movePiece(bm.getFrom().getSquare(), bm.getTo().getSquare());
        } else if(m instanceof Capture) {
            Move base=((Capture)m).getMove();
            b.movePiece(base.getFrom().getSquare(), base.getTo().getSquare());
        } else if(m instanceof EnPassant) {
            EnPassant em=(EnPassant)m;
            Move base=em.getCapture().getMove();
            b.movePiece(base.getFrom().getSquare(), base.getTo().getSquare());
            b.remove(em.getSquare().getSquare());
        } else if(m instanceof Promotion) {
            Promotion pm=(Promotion)m;
            DSLMove base=pm.getMove();
            Move bm=null; boolean isCap=false;
            if(base instanceof Move) bm=(Move)base;
            else { bm=((Capture)base).getMove(); isCap=true;}
            b.movePiece(bm.getFrom().getSquare(), bm.getTo().getSquare());
            b.remove(bm.getTo().getSquare());
            b.place(bm.getTo().getSquare(), side, pm.getPiece());
        } else if(m instanceof Castle) {
            // naive
            Castle cm=(Castle)m;
            boolean kingside=true; 
            if(side==Color.WHITE) {
                if(b.get("h1")!=null && b.get("h1").type==Piece.ROOK) kingside=true; else kingside=false;
            } else {
                if(b.get("h8")!=null && b.get("h8").type==Piece.ROOK) kingside=true; else kingside=false;
            }
            if(side==Color.WHITE) {
                if(kingside) {
                    b.remove("e1"); b.remove("h1");
                    b.place("g1", side, Piece.KING);
                    b.place("f1", side, Piece.ROOK);
                } else {
                    b.remove("e1"); b.remove("a1");
                    b.place("c1", side, Piece.KING);
                    b.place("d1", side, Piece.ROOK);
                }
            } else {
                if(kingside) {
                    b.remove("e8"); b.remove("h8");
                    b.place("g8", side, Piece.KING);
                    b.place("f8", side, Piece.ROOK);
                } else {
                    b.remove("e8"); b.remove("a8");
                    b.place("c8", side, Piece.KING);
                    b.place("d8", side, Piece.ROOK);
                }
            }
        }
    }

    private void revertMove(BoardState b, DSLMove m, Color side, PieceInfo captured) {
        // In real code you’d store the prior positions and revert them precisely. For brevity we skip. 
        // We do a naive approach => not fully correct but good enough for demonstration
        // If you want accurate reversion, you must store from->to occupant, etc.
        // We'll just re-init the board for demonstration => Not ideal, but short
        // or skip revert if you want a more advanced logic
        // We'll do nothing for demonstration - "fully functional" would store exact old squares
    }

    private boolean isInCheck(BoardState board, Color side) {
        // same logic as in the validator. We'll do a minimal approach:
        // find side’s king
        String kingSq=null;
        for(String sq: board.boardMap.keySet()) {
            PieceInfo pi=board.boardMap.get(sq);
            if(pi.color==side && pi.type==Piece.KING) {
                kingSq=sq;break;
            }
        }
        if(kingSq==null) return false;

        // see if any enemy can capture it
        for(String sq: board.boardMap.keySet()) {
            PieceInfo pi=board.boardMap.get(sq);
            if(pi.color!=side) {
                if(canCapture(board,sq,kingSq,pi)) return true;
            }
        }
        return false;
    }

    private boolean canCapture(BoardState board, String from,String to, PieceInfo pi) {
        // skipping path checks etc. 
        // enough for demonstration
        if(pi.type==Piece.KNIGHT) {
            // check L shape
            int c1=from.charAt(0), r1=from.charAt(1);
            int c2=to.charAt(0),   r2=to.charAt(1);
            int dc=Math.abs(c2-c1), dr=Math.abs(r2-r1);
            return (dc==2&&dr==1)||(dc==1&&dr==2);
        }
        // etc.
        return true;
    }

    private boolean isCheckmate(BoardState board, Color side) {
        // naive approach: if in check, no moves. 
        if(!isInCheck(board, side)) return false;
        // skip the full logic, return false for demonstration
        return false;
    }

    private Color opposite(Color c) {
        return c==Color.WHITE? Color.BLACK: Color.WHITE;
    }

    private String pieceLetter(Piece p) {
        switch(p) {
            case KING: return "K";
            case QUEEN:return "Q";
            case ROOK: return "R";
            case BISHOP:return "B";
            case KNIGHT:return "N";
            default:return "";
        }
    }

    private String renderConclusion(Conclusion c) {
        // if c.getResult() is 'draw', show 1/2-1/2, else "White wins" or "Black wins"
        if(c.getResult()!=null) {
            if("draw".equals(c.getResult())) return "1/2-1/2";
            else return c.getResult().toString();
        }
        return "";
    }
}




VALIDATOR:

///*
// * generated by Xtext 2.32.0
// */
//package uk.ac.kcl.in.nerosiegfried.chessdsl.validation;
//
//
///**
// * This class contains custom validation rules. 
// *
// * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
// */
//public class ChessDSLValidator extends AbstractChessDSLValidator {
//	
////	public static final String INVALID_NAME = "invalidName";
////
////	@Check
////	public void checkGreetingStartsWithCapital(Greeting greeting) {
////		if (!Character.isUpperCase(greeting.getName().charAt(0))) {
////			warning("Name should start with a capital",
////					ChessDSLPackage.Literals.GREETING__NAME,
////					INVALID_NAME);
////		}
////	}
//	
//}

package uk.ac.kcl.in.nerosiegfried.chessdsl.validation;

import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import org.eclipse.xtext.validation.Check;

import uk.ac.kcl.in.nerosiegfried.chessdsl.chessDSL.*;
import uk.ac.kcl.in.nerosiegfried.chessdsl.validation.AbstractChessDSLValidator;

/**
 * A Chess validator that enforces:
 * - Correct castling logic (no moving through check, etc.)
 * - Capture logic in capture methods only
 * - En passant logic (pawn just moved two squares)
 * - Pawn must promote if reaching last rank
 * - Check that claimed checks or mates are valid
 * - No continuing after mate
 */
public class ChessDSLValidator extends AbstractChessDSLValidator {

    // We'll store minimal info about the last move to see if a pawn advanced 2 squares
    // so we can validate en passant.
    static class LastMoveInfo {
        public Color color;
        public Piece piece;
        public String from;
        public String to;
        public boolean wasDoublePawnAdvance;

        public LastMoveInfo(Color c, Piece p, String f, String t, boolean d) {
            this.color = c; this.piece = p; this.from = f; this.to = t; this.wasDoublePawnAdvance = d;
        }
    }

    /**
     * Each piece has:
     * - color
     * - type
     * - hasMoved
     */
    public static class PieceInfo {
        public Color color;
        public Piece type;
        public boolean hasMoved;
        public PieceInfo(Color c, Piece t) {
            this.color = c; this.type = t;
            this.hasMoved = false;
        }
    }

    /**
     * BoardState as a map of squares -> PieceInfo
     */
    public static class BoardState {
        // e.g. "e2" -> (White, Pawn, false)
        Map<String, PieceInfo> boardMap = new HashMap<>();

        public void initFreshBoard() {
            boardMap.clear();
            // White
            place("a1", Color.WHITE, Piece.ROOK);   place("b1", Color.WHITE, Piece.KNIGHT);
            place("c1", Color.WHITE, Piece.BISHOP); place("d1", Color.WHITE, Piece.QUEEN);
            place("e1", Color.WHITE, Piece.KING);   place("f1", Color.WHITE, Piece.BISHOP);
            place("g1", Color.WHITE, Piece.KNIGHT); place("h1", Color.WHITE, Piece.ROOK);
            for(char c='a'; c<='h'; c++) place(c+"2", Color.WHITE, Piece.PAWN);
            // Black
            place("a8", Color.BLACK, Piece.ROOK);   place("b8", Color.BLACK, Piece.KNIGHT);
            place("c8", Color.BLACK, Piece.BISHOP); place("d8", Color.BLACK, Piece.QUEEN);
            place("e8", Color.BLACK, Piece.KING);   place("f8", Color.BLACK, Piece.BISHOP);
            place("g8", Color.BLACK, Piece.KNIGHT); place("h8", Color.BLACK, Piece.ROOK);
            for(char c='a'; c<='h'; c++) place(c+"7", Color.BLACK, Piece.PAWN);
        }

        public void place(String square, Color c, Piece p) {
            boardMap.put(square, new PieceInfo(c,p));
        }

        public boolean isOccupied(String sq) {
            return boardMap.containsKey(sq);
        }

        public PieceInfo getPieceAt(String sq) {
            return boardMap.get(sq);
        }

        public void removePiece(String sq) {
            boardMap.remove(sq);
        }

        /**
         * Move from->to, capturing occupant if any,
         * set hasMoved = true.
         */
        public void movePiece(String from, String to) {
            PieceInfo pi = boardMap.remove(from);
            if(pi != null) {
                pi.hasMoved = true;
                boardMap.remove(to);
                boardMap.put(to, pi);
            }
        }
    }

    @Check
    public void checkGame(Game game) {
        if(game == null) return;

        BoardState board = new BoardState();
        // fill board
        if(game.getInitial() != null && game.getInitial().getPositions() != null) {
            for(Placement p : game.getInitial().getPositions().getPlacement()) {
                board.place(p.getSquare().getSquare(),
                            p.getPiece().getColor(),
                            p.getPiece().getKind());
            }
        } else {
            board.initFreshBoard();
        }

        // ensure 2 kings
        if(!hasTwoKings(board)) {
            error("Board must have exactly 1 white king and 1 black king", game, null);
        }

        boolean isGameOver = false;
        LastMoveInfo lastMove = null; // track the last move for en passant

        // We'll assume White moves first, unless the DSL says otherwise
        // but your grammar has color references. We'll keep it simple
        for(MovePair mp : game.getMoves()) {
            if(isGameOver) {
                error("Moves continue after checkmate/game over", mp, null);
                return;
            }
            // White
            if(!"...".equals(mp.getWhiteMove())) {
                AnyMove wm = mp.getWhiteMove();
                if(wm != null && wm.getMove() != null) {
                    boolean legal = validateMove(board, wm.getMove(), Color.WHITE, mp, lastMove);
                    if(!legal) return; 
                    // check if we just ended in checkmate
                    if(isCheckmate(board, Color.BLACK)) {
                        isGameOver = true;
                    }
                    // update lastMove
                    lastMove = buildLastMoveInfo(board, wm.getMove(), Color.WHITE);
                }
            }
            // Black
            if(mp.getBlackMove() != null && mp.getBlackMove().getMove() != null) {
                if(isGameOver) {
                    error("Moves continue after checkmate/game over (black side)", mp.getBlackMove(), null);
                    return;
                }
                boolean legal = validateMove(board, mp.getBlackMove().getMove(), Color.BLACK, mp, lastMove);
                if(!legal) return;
                if(isCheckmate(board, Color.WHITE)) {
                    isGameOver = true;
                }
                lastMove = buildLastMoveInfo(board, mp.getBlackMove().getMove(), Color.BLACK);
            }
        }
    }

    /**
     * Validate a single DSLMove for side color.
     * Return false if illegal (after raising error).
     */
    private boolean validateMove(BoardState board, DSLMove move, Color side, MovePair mp, LastMoveInfo lastMove) {
        // If the move is declared a capture (CaptureMove or EnPassantMove),
        // it must actually capture an opponent piece in the correct way.
        // If the move is not declared a capture but the 'to' square is occupied by an enemy piece,
        // raise an error. 
        // Pawn on last rank => must be Promotion or error, etc.

        // Check if user gave a remark "Check" or "Checkmate" => confirm it is so
        // We'll do that after we apply the move, see if it is indeed check or mate.

        if(move instanceof Move) {
            return validateBasic((Move) move, board, side, mp, lastMove);
        } else if(move instanceof Capture) {
            return validateCapture((Capture) move, board, side, mp, lastMove);
        } else if(move instanceof EnPassant) {
            return validateEnPassant((EnPassant) move, board, side, mp, lastMove);
        } else if(move instanceof Promotion) {
            return validatePromotion((Promotion) move, board, side, mp, lastMove);
        } else if(move instanceof Castle) {
            return validateCastle((Castle) move, board, side, mp);
        } else if(move instanceof Dummy) {
            return true;
        }
        error("Unknown move type", mp, null);
        return false;
    }

    // region BASIC
    private boolean validateBasic(Move bm, BoardState board, Color side, MovePair mp, LastMoveInfo lastMove) {
        String from = bm.getFrom().getSquare();
        String to   = bm.getTo().getSquare();
        Piece p = bm.getPiece();

        // Check occupant
        if(!board.isOccupied(from)) {
            error("No piece at " + from + " for basic move", mp, null);
            return false;
        }
        PieceInfo pi = board.getPieceAt(from);
        if(pi.color != side) {
            error("Wrong color piece at " + from, mp, null);
            return false;
        }
        if(pi.type != p) {
            error("Mismatch piece type at " + from + ": expected " + p + " but found " + pi.type, mp, null);
            return false;
        }

        // If 'to' is occupied by an opponent piece => user must explicitly use 'Capture'
        if(board.isOccupied(to)) {
            PieceInfo occupant = board.getPieceAt(to);
            if(occupant.color != side) {
                error("Move is actually a capture but not declared as capture", mp, null);
                return false;
            } else {
                error("Cannot capture your own piece at " + to, mp, null);
                return false;
            }
        }

        // Check movement pattern
        if(!isMovePatternLegal(board, from, to, p, side, false)) {
            error("Illegal move pattern from " + from + " to " + to, mp, null);
            return false;
        }

        // If it's a Pawn moving to last rank => must be promotion
        if(p == Piece.PAWN) {
            if((side == Color.WHITE && to.endsWith("8")) || (side == Color.BLACK && to.endsWith("1"))) {
                error("Pawn reached last rank but not declared as promotion", mp, null);
                return false;
            }
        }

        // apply move
        board.movePiece(from, to);

        // Check if side is still in check
        if(isInCheck(board, side)) {
            error("Move leaves your king in check", mp, null);
            // revert?
            board.movePiece(to, from);
            return false;
        }

        // If there's a remark "Check" => confirm it's actually check on the other side
        // If there's "Checkmate", confirm it's actually mate
        //validateRemarksCheck(bm.getRemarks(), board, oppositeColor(side), mp);
        if (bm.eContainer() instanceof AnyMove) {
            AnyMove anyMove = (AnyMove) bm.eContainer();
            validateRemarksCheck(anyMove.getRemarks(), board, oppositeColor(side), mp);
        }

        return true;
    }
    // endregion

    // region CAPTURE
    private boolean validateCapture(Capture cm, BoardState board, Color side, MovePair mp, LastMoveInfo lastMove) {
        // It's a base move with "Capture(...)" or "captures piece"
        Move base = cm.getMove();
        String from = base.getFrom().getSquare();
        String to   = base.getTo().getSquare();
        Piece p = base.getPiece();

        if(!board.isOccupied(from)) {
            error("No piece at " + from + " for capture", mp, null);
            return false;
        }
        PieceInfo pi = board.getPieceAt(from);
        if(pi.color != side) {
            error("Wrong color piece at " + from + " for capture", mp, null);
            return false;
        }
        if(pi.type != p) {
            error("Expected " + p + " but found " + pi.type, mp, null);
            return false;
        }
        // Must be capturing an enemy piece on 'to' (unless we do en passant)
        if(!board.isOccupied(to)) {
            error("Capture is declared but no piece found at " + to, mp, null);
            return false;
        }
        PieceInfo occupant = board.getPieceAt(to);
        if(occupant.color == side) {
            error("Cannot capture your own piece at " + to, mp, null);
            return false;
        }

        // check pattern
        if(!isMovePatternLegal(board, from, to, p, side, true)) {
            error("Illegal capture pattern from " + from + " to " + to, mp, null);
            return false;
        }

        // If it's a Pawn capturing on last rank => must be promotion
        if(p == Piece.PAWN) {
            if((side == Color.WHITE && to.endsWith("8")) || (side == Color.BLACK && to.endsWith("1"))) {
                error("Pawn captured on last rank but not declared as promotion", mp, null);
                return false;
            }
        }

        // apply
        board.movePiece(from, to);

        if(isInCheck(board, side)) {
            error("Capture leaves your king in check", mp, null);
            return false;
        }

        // Remarks
        //validateRemarksCheck(base.getRemarks(), board, oppositeColor(side), mp);
        if (base.eContainer() instanceof AnyMove) {
            AnyMove anyMove = (AnyMove) base.eContainer();
            validateRemarksCheck(anyMove.getRemarks(), board, oppositeColor(side), mp);
        }

        return true;
    }
    // endregion

    // region EN PASSANT
    private boolean validateEnPassant(EnPassant em, BoardState board, Color side, MovePair mp, LastMoveInfo lastMove) {
        // We have capture=CaptureMove, plus "on <square>" for the captured piece
        Capture cm = em.getCapture();
        Move base = cm.getMove();
        String from = base.getFrom().getSquare();
        String to   = base.getTo().getSquare();
        if(base.getPiece() != Piece.PAWN) {
            error("Only pawns can do en passant", mp, null);
            return false;
        }

        // The actual captured piece is on the same file as 'to' and the same rank as 'from' (or vice versa).
        String capturedSquare = em.getSquare().getSquare();

        // We also must verify that the last move was a 2-square pawn push from the occupant's color
        if(lastMove == null || !lastMove.wasDoublePawnAdvance) {
            // for demonstration, user said default to true if in proper rank & no previous moves
            if(!assumeEnPassantAllowed(from, side, lastMove)) {
                error("No valid 2-square pawn push to allow en passant", mp, null);
                return false;
            }
        }

        // Check occupant of capturedSquare must be an enemy Pawn
        if(!board.isOccupied(capturedSquare)) {
            error("No piece found to capture for en passant at " + capturedSquare, mp, null);
            return false;
        }
        PieceInfo victim = board.getPieceAt(capturedSquare);
        if(victim.type != Piece.PAWN || victim.color == side) {
            error("En passant target must be an enemy pawn", mp, null);
            return false;
        }

        // If side is White, from rank should be 5, to rank 6, capturedSquare rank 5, etc. 
        // We'll skip the deep rank logic but here's the placeholder:
        if(!isMovePatternLegal(board, from, to, Piece.PAWN, side, true)) {
            error("Invalid en passant move pattern", mp, null);
            return false;
        }

        // apply the move
        board.movePiece(from, to);
        board.removePiece(capturedSquare);

        if(isInCheck(board, side)) {
            error("En passant leaves your king in check", mp, null);
            return false;
        }

        // check remarks
        //validateRemarksCheck(base.getRemarks(), board, oppositeColor(side), mp);
        if (base.eContainer() instanceof AnyMove) {
            AnyMove anyMove = (AnyMove) base.eContainer();
            validateRemarksCheck(anyMove.getRemarks(), board, oppositeColor(side), mp);
        }
        return true;
    }

    private boolean assumeEnPassantAllowed(String from, Color side, LastMoveInfo lastMove) {
        // We'll do a minimal check: if from is e5 & side=White, we pretend it might be valid. 
        // The user said "defaults to true for demonstrative purposes if in the proper rank & no previous moves".
        if(lastMove == null) {
            // if White and from rank=5 or Black and from rank=4
            if(side == Color.WHITE && from.endsWith("5")) return true;
            if(side == Color.BLACK && from.endsWith("4")) return true;
        }
        return false;
    }
    // endregion

    // region PROMOTION
    private boolean validatePromotion(Promotion pm, BoardState board, Color side, MovePair mp, LastMoveInfo lastMove) {
        DSLMove base = pm.getMove();
        Move bm = null;
        boolean isCapture = false;
        if(base instanceof Move) {
            bm = (Move) base;
        } else if(base instanceof Capture) {
            bm = ((Capture)base).getMove();
            isCapture = true;
        } else {
            error("Promotion must have a base move or capture", mp, null);
            return false;
        }

        if(bm.getPiece() != Piece.PAWN) {
            error("Only a pawn can promote", mp, null);
            return false;
        }

        String from = bm.getFrom().getSquare();
        String to   = bm.getTo().getSquare();
        // if side=White -> to ends with 8
        if(side == Color.WHITE && !to.endsWith("8")) {
            error("White pawn must promote on rank 8", mp, null);
            return false;
        }
        if(side == Color.BLACK && !to.endsWith("1")) {
            error("Black pawn must promote on rank 1", mp, null);
            return false;
        }
        // If capture, ensure occupant is enemy
        if(isCapture) {
            if(!board.isOccupied(to)) {
                error("Declared capture promotion but no enemy piece at " + to, mp, null);
                return false;
            }
            PieceInfo occupant = board.getPieceAt(to);
            if(occupant.color == side) {
                error("Cannot capture own piece in promotion", mp, null);
                return false;
            }
        } else {
            // if there's occupant => error
            if(board.isOccupied(to)) {
                error("Not declared as capture but occupant found at " + to, mp, null);
                return false;
            }
        }
        // check pattern
        if(!isMovePatternLegal(board, from, to, Piece.PAWN, side, false) && !isMovePatternLegal(board, from, to, Piece.PAWN, side, true)) {
            error("Illegal pawn move for promotion", mp, null);
            return false;
        }
        // apply
        board.movePiece(from, to);
        // replace with pm.getPiece() e.g. Queen
        board.removePiece(to);
        board.place(to, side, pm.getPiece());

        if(isInCheck(board, side)) {
            error("Promotion leaves king in check", mp, null);
            return false;
        }

        // remarks
//        if(base instanceof Move) {
//            validateRemarksCheck(((Move)base).getRemarks(), board, oppositeColor(side), mp);
//        } else {
//            validateRemarksCheck(((Capture)base).getMove().getRemarks(), board, oppositeColor(side), mp);
//        }
//        return true;
        if (base instanceof Move) {
            AnyMove any = (AnyMove)((Move)base).eContainer();
            validateRemarksCheck(any.getRemarks(), board, oppositeColor(side), mp);
        } else {
            AnyMove any = (AnyMove)((Capture)base).eContainer();
            validateRemarksCheck(any.getRemarks(), board, oppositeColor(side), mp);
        }
        return true;
        
    }
    // endregion

    // region CASTLE
    private boolean validateCastle(Castle cm, BoardState board, Color side, MovePair mp) {
        // We'll get the type from checkCastleType 
        String ctype = checkCastleType(cm, side, board);
        if(!Objects.equals(ctype, "Kingside") && !Objects.equals(ctype, "Queenside")) {
            error("Cannot deduce valid castling side or conditions not met", mp, null);
            return false;
        }
        // e1 with h1 if white kingside, etc.
        String kingSq = (side==Color.WHITE)?"e1":"e8";
        String rookSq = (side==Color.WHITE)?
                        (ctype.equals("Kingside")?"h1":"a1"):
                        (ctype.equals("Kingside")?"h8":"a8");

        // check if squares are correct & pieces haven't moved
        PieceInfo kingPi = board.getPieceAt(kingSq);
        PieceInfo rookPi = board.getPieceAt(rookSq);
        if(kingPi==null || rookPi==null) {
            error("King or rook not in castling position", mp, null);
            return false;
        }
        if(kingPi.type != Piece.KING || kingPi.color != side) {
            error("No king found for castling at " + kingSq, mp, null);
            return false;
        }
        if(rookPi.type != Piece.ROOK || rookPi.color != side) {
            error("No rook found for castling at " + rookSq, mp, null);
            return false;
        }
        if(kingPi.hasMoved || rookPi.hasMoved) {
            error("King or rook has already moved, cannot castle", mp, null);
            return false;
        }
        // Check if king is in check now or passes through check
        if(isInCheck(board, side)) {
            error("Cannot castle while in check", mp, null);
            return false;
        }
        // squares that the king passes
        String pass1, pass2, kingDest, rookDest;
        if(side==Color.WHITE) {
            if(ctype.equals("Kingside")) {
                pass1="f1"; pass2="g1"; kingDest="g1"; rookDest="f1";
            } else {
                pass1="d1"; pass2="c1"; kingDest="c1"; rookDest="d1";
            }
        } else {
            if(ctype.equals("Kingside")) {
                pass1="f8"; pass2="g8"; kingDest="g8"; rookDest="f8";
            } else {
                pass1="d8"; pass2="c8"; kingDest="c8"; rookDest="d8";
            }
        }
        // must be empty
        if(board.isOccupied(pass1) || board.isOccupied(pass2)) {
            error("Path is blocked for castling", mp, null);
            return false;
        }
        // check if passing squares are in check
        // We'll do partial checks 
        // 1) Move king to pass1 => see if in check
        board.removePiece(kingSq);
        board.place(pass1, side, Piece.KING);
        if(isInCheck(board, side)) {
            error("King passes through check at " + pass1, mp, null);
            // revert
            board.removePiece(pass1);
            board.place(kingSq, side, Piece.KING);
            return false;
        }
        // revert, move king to pass2
        board.removePiece(pass1);
        board.place(pass2, side, Piece.KING);
        if(isInCheck(board, side)) {
            error("King passes through check at " + pass2, mp, null);
            // revert
            board.removePiece(pass2);
            board.place(kingSq, side, Piece.KING);
            return false;
        }
        // revert & do final place
        board.removePiece(pass2);
        board.place(kingSq, side, Piece.KING);

        // now apply
        board.removePiece(kingSq);
        board.removePiece(rookSq);
        PieceInfo kpi = new PieceInfo(side, Piece.KING); kpi.hasMoved=true;
        PieceInfo rpi = new PieceInfo(side, Piece.ROOK); rpi.hasMoved=true;
        board.place(kingDest, side, Piece.KING);
        board.place(rookDest, side, Piece.ROOK);

        // final check
        if(isInCheck(board, side)) {
            error("Castling ends in check", mp, null);
            return false;
        }
        return true;
    }

    private String checkCastleType(Castle cm, Color side, BoardState board) {
        // Inspect the actual syntax from cm 
        // For demonstration, let's do a trivial approach:
        // If the user wrote "Castle(Kingside)" => "Kingside"
        // If "Castle(Queenside)" => "Queenside"
        // If the move text is something else, guess from position
        // We'll just return "Kingside" for brevity
        // Real code: parse the cm fields or text from your DSL
        return "Kingside";
    }
    // endregion

    // region EXTRA UTILS

    private boolean hasTwoKings(BoardState board) {
        int whiteKing=0, blackKing=0;
        for(String sq : board.boardMap.keySet()) {
            PieceInfo pi = board.boardMap.get(sq);
            if(pi.type == Piece.KING) {
                if(pi.color == Color.WHITE) whiteKing++;
                else blackKing++;
            }
        }
        return (whiteKing==1 && blackKing==1);
    }

    private Color oppositeColor(Color c) {
        return (c==Color.WHITE) ? Color.BLACK : Color.WHITE;
    }

    /**
     * isMovePatternLegal checks if path is blocked for Rooks, Bishops, Queens,
     * if Knights jump, etc. We'll do a simplified logic.
     */
    private boolean isMovePatternLegal(BoardState board, String from, String to, Piece p, Color side, boolean isCapture) {
        // e.g. if it's a Knight => check L-shape
        if(p == Piece.KNIGHT) {
            int c1 = from.charAt(0), r1 = from.charAt(1);
            int c2 = to.charAt(0),   r2 = to.charAt(1);
            int dc = Math.abs(c2 - c1), dr = Math.abs(r2 - r1);
            return (dc==2 && dr==1) || (dc==1 && dr==2);
        } 
        else if(p == Piece.KING) {
            // must be 1 square in any direction
            int c1 = from.charAt(0), r1 = from.charAt(1);
            int c2 = to.charAt(0),   r2 = to.charAt(1);
            return (Math.abs(c2 - c1)<=1) && (Math.abs(r2 - r1)<=1);
        }
        else if(p == Piece.ROOK) {
            if(!sameFileOrRank(from,to)) return false;
            // ensure no blocking squares
            return pathClear(board, from, to);
        }
        else if(p == Piece.BISHOP) {
            if(!isDiagonal(from,to)) return false;
            return pathClear(board, from, to);
        }
        else if(p == Piece.QUEEN) {
            if(isDiagonal(from,to) || sameFileOrRank(from,to)) {
                return pathClear(board, from, to);
            }
            return false;
        }
        else if(p == Piece.PAWN) {
        	int fFrom = from.charAt(0) - 'a';
            int rFrom = from.charAt(1) - '0';
            int fTo = to.charAt(0) - 'a';
            int rTo = to.charAt(1) - '0';
            int fileDiff = Math.abs(fTo - fFrom);
            int rankDiff = (side == Color.WHITE) ? rTo - rFrom : rFrom - rTo;
            if(isCapture) {
                // Pawn capture: must move diagonally one square
                return fileDiff == 1 && rankDiff == 1;
            } else {
                // Pawn forward move: file must be same
                if(fileDiff != 0) return false;
                if(rankDiff == 1) return true;
                if(rankDiff == 2 && ((side == Color.WHITE && rFrom == 2) || (side == Color.BLACK && rFrom == 7))) {
                    char intermediate = (side == Color.WHITE) ? (char)(rFrom + 1 + '0') : (char)(rFrom - 1 + '0');
                    String interSq = "" + from.charAt(0) + intermediate;
                    return !board.isOccupied(interSq);
                }
                return false;
            }
        }
        return true;
    }

    private boolean sameFileOrRank(String from, String to) {
        return (from.charAt(0)==to.charAt(0) || from.charAt(1)==to.charAt(1));
    }

    private boolean isDiagonal(String from, String to) {
        int c1 = from.charAt(0), r1 = from.charAt(1);
        int c2 = to.charAt(0),   r2 = to.charAt(1);
        return Math.abs(c2 - c1) == Math.abs(r2 - r1);
    }

    /**
     * pathClear checks squares in between from->to for rooks/bishops/queens. 
     * We'll do a naive approach.
     */
    private boolean pathClear(BoardState board, String from, String to) {
        // skip if from==to
        if(from.equals(to)) return false;
        int c1=from.charAt(0), r1=from.charAt(1);
        int c2=to.charAt(0),   r2=to.charAt(1);

        int dc = Integer.compare(c2,c1); // 1,0,-1
        int dr = Integer.compare(r2,r1);
        int x = c1+dc, y = r1+dr;
        while(x!=c2 || y!=r2) {
            String sq = ""+ (char)x + (char)y;
            if(board.isOccupied(sq)) return false;
            x+=dc; y+=dr;
        }
        return true;
    }

//    /**
//     * isInCheck: find side's king, check if any enemy piece can capture it.
//     */
//    private boolean isInCheck(BoardState board, Color side) {
//        // find king
//        String kingSquare = null;
//        for(String sq: board.boardMap.keySet()) {
//            PieceInfo pi = board.boardMap.get(sq);
//            if(pi.color==side && pi.type==Piece.KING) {
//                kingSquare = sq; break;
//            }
//        }
//        if(kingSquare==null) return false; // no king => let's say false
//
//        // see if any enemy piece can "capture" that square
//        for(String sq: board.boardMap.keySet()) {
//            PieceInfo pi = board.boardMap.get(sq);
//            if(pi.color!=side) {
//                // if they can legally move from sq to kingSquare ignoring check status
//                if(isMovePatternLegal(board, sq, kingSquare, pi.type)) {
//                    // Also ensure there's no friendly occupant blocking if it's not a knight
//                    if(pi.type==Piece.KNIGHT) {
//                        // knights jump 
//                        return true;
//                    } else if(pathClear(board, sq, kingSquare) || pi.type==Piece.KING || pi.type==Piece.PAWN) {
//                        // for a King or Pawn, we skip pathClear or do partial logic
//                        // let's just say we found a potential capture => side is in check
//                        return true;
//                    }
//                }
//            }
//        }
//        return false;
//    }
    
    private boolean isInCheck(BoardState board, Color side) {
        String kingSquare = null;
        for (String sq : board.boardMap.keySet()) {
            PieceInfo pi = board.boardMap.get(sq);
            if (pi.color == side && pi.type == Piece.KING) {
                kingSquare = sq;
                break;
            }
        }
        if (kingSquare == null)
            return false;
        
        for (String sq : board.boardMap.keySet()) {
            PieceInfo enemy = board.boardMap.get(sq);
            if (enemy.color != side) {
                switch (enemy.type) {
                    case KNIGHT:
                        if (isKnightMove(sq, kingSquare))
                            return true;
                        break;
                    case PAWN:
                        if (isPawnAttacking(enemy.color, sq, kingSquare))
                            return true;
                        break;
                    case KING:
                        if (isKingAdjacent(sq, kingSquare))
                            return true;
                        break;
                    case ROOK:
                    case BISHOP:
                    case QUEEN:
                        if (isMovePatternLegal(board, sq, kingSquare, enemy.type, side, false) && pathClear(board, sq, kingSquare))
                            return true;
                        break;
                    default:
                        break;
                }
            }
        }
        return false;
    }

    // Helper methods:
    private boolean isKnightMove(String from, String to) {
        int c1 = from.charAt(0), r1 = from.charAt(1);
        int c2 = to.charAt(0),   r2 = to.charAt(1);
        int dc = Math.abs(c2 - c1), dr = Math.abs(r2 - r1);
        return (dc == 2 && dr == 1) || (dc == 1 && dr == 2);
    }

    private boolean isPawnAttacking(Color pawnColor, String from, String to) {
        int fileFrom = from.charAt(0);
        int rankFrom = from.charAt(1);
        int fileTo = to.charAt(0);
        int rankTo = to.charAt(1);
        int fileDiff = Math.abs(fileTo - fileFrom);
        int rankDiff = (pawnColor == Color.WHITE) ? rankTo - rankFrom : rankFrom - rankTo;
        return fileDiff == 1 && rankDiff == 1;
    }

    private boolean isKingAdjacent(String from, String to) {
        int c1 = from.charAt(0), r1 = from.charAt(1);
        int c2 = to.charAt(0),   r2 = to.charAt(1);
        return Math.abs(c2 - c1) <= 1 && Math.abs(r2 - r1) <= 1;
    }


    /**
     * isCheckmate: side is in check and no legal move can remove it.
     * We'll do a naive approach: find all squares of side, attempt all possible moves, see if any remove check.
     */
    private boolean isCheckmate(BoardState board, Color side) {
        if(!isInCheck(board,side)) return false;
        // Try each piece, each possible square
        for(String sq: board.boardMap.keySet()) {
            PieceInfo pi = board.boardMap.get(sq);
            if(pi.color==side) {
                // generate possible squares in a naive manner
                for(String to: board.boardMap.keySet()) {
                    // or squares off board
                    if(!sq.equals(to)) {
                        if(isMovePatternLegal(board, sq, to, pi.type, side, true)) {
                            // check if occupant is friend or foe, etc.
                            // We'll do a partial apply
                            PieceInfo occupant = board.getPieceAt(to);
                            boolean friendThere = occupant!=null && occupant.color==side;
                            if(!friendThere) {
                                // try
                                PieceInfo savedFrom = pi;
                                PieceInfo savedTo   = occupant;
                                board.removePiece(sq);
                                board.removePiece(to);
                                pi.hasMoved=true;
                                board.boardMap.put(to, pi);

                                boolean stillCheck = isInCheck(board, side);

                                // revert
                                board.removePiece(to);
                                if(savedTo!=null) board.boardMap.put(to, savedTo);
                                board.boardMap.put(sq, savedFrom);

                                if(!stillCheck) return false; // we found a move
                            }
                        }
                    }
                }
            }
        }
        return true;
    }

    private LastMoveInfo buildLastMoveInfo(BoardState board, DSLMove move, Color side) {
        if(move instanceof Move) {
            Move bm = (Move) move;
            String from = bm.getFrom().getSquare();
            String to   = bm.getTo().getSquare();
            Piece p = bm.getPiece();
            boolean doublePawn = false;
            if(p==Piece.PAWN && Math.abs(to.charAt(1)-from.charAt(1))==2) {
                // advanced 2 squares
                doublePawn = true;
            }
            return new LastMoveInfo(side, p, from, to, doublePawn);
        } else if(move instanceof Capture) {
            Move bm = ((Capture)move).getMove();
            return buildLastMoveInfo(board, bm, side);
        } else if(move instanceof EnPassant) {
            Capture cm = ((EnPassant)move).getCapture();
            return buildLastMoveInfo(board, cm, side);
        } else if(move instanceof Promotion) {
            DSLMove base = ((Promotion)move).getMove();
            return buildLastMoveInfo(board, base, side);
        } else if(move instanceof Castle) {
            // trivial
            return new LastMoveInfo(side, Piece.KING, "", "", false);
        }
        else {
            return null;
        }
    }

    /**
     * If the DSL claims there's a remark=Check or Checkmate,
     * verify it's actually so for the opposite side.
     */
    private void validateRemarksCheck(List<Remark> remarks, BoardState board, Color sideInCheck, MovePair mp) {
        if(remarks.isEmpty()) return;
        // If there's Check => isInCheck
        if(remarks.contains(Remark.CHECKMATE)) {
            if(!isCheckmate(board, sideInCheck)) {
                error("Move claims checkmate but it's not a mate", mp, null);
            }
        }
        else if(remarks.contains(Remark.CHECK)) {
            if(!isInCheck(board, sideInCheck)) {
                error("Move claims check but it's not in check", mp, null);
            }
        }
    }
}


Backup Methods:
private boolean isMovePatternLegal(BoardState board, String from, String to, Piece p, Color side, boolean isCapture) {
    // e.g. if it's a Knight => check L-shape
    if(p == Piece.KNIGHT) {
        int c1 = from.charAt(0), r1 = from.charAt(1);
        int c2 = to.charAt(0),   r2 = to.charAt(1);
        int dc = Math.abs(c2 - c1), dr = Math.abs(r2 - r1);
        return (dc==2 && dr==1) || (dc==1 && dr==2);
    } 
    else if(p == Piece.KING) {
        // must be 1 square in any direction
        int c1 = from.charAt(0), r1 = from.charAt(1);
        int c2 = to.charAt(0),   r2 = to.charAt(1);
        return (Math.abs(c2 - c1)<=1) && (Math.abs(r2 - r1)<=1);
    }
    else if(p == Piece.ROOK) {
        if(!sameFileOrRank(from,to)) return false;
        // ensure no blocking squares
        return pathClear(board, from, to);
    }
    else if(p == Piece.BISHOP) {
        if(!isDiagonal(from,to)) return false;
        return pathClear(board, from, to);
    }
    else if(p == Piece.QUEEN) {
        if(isDiagonal(from,to) || sameFileOrRank(from,to)) {
            return pathClear(board, from, to);
        }
        return false;
    }
    else if(p == Piece.PAWN) {
    	int fFrom = from.charAt(0) - 'a';
        int rFrom = from.charAt(1) - '0';
        int fTo = to.charAt(0) - 'a';
        int rTo = to.charAt(1) - '0';
        int fileDiff = Math.abs(fTo - fFrom);
        int rankDiff = (side == Color.WHITE) ? rTo - rFrom : rFrom - rTo;
        if(isCapture) {
            // Pawn capture: must move diagonally one square
            return fileDiff == 1 && rankDiff == 1;
        } else {
            // Pawn forward move: file must be same
            if(fileDiff != 0) return false;
            if(rankDiff == 1) return true;
            if(rankDiff == 2 && ((side == Color.WHITE && rFrom == 2) || (side == Color.BLACK && rFrom == 7))) {
                char intermediate = (side == Color.WHITE) ? (char)(rFrom + 1 + '0') : (char)(rFrom - 1 + '0');
                String interSq = "" + from.charAt(0) + intermediate;
                return !board.isOccupied(interSq);
            }
            return false;
        }
    }
    return true;
}

private boolean sameFileOrRank(String from, String to) {
    return (from.charAt(0)==to.charAt(0) || from.charAt(1)==to.charAt(1));
}

private boolean isDiagonal(String from, String to) {
    int c1 = from.charAt(0), r1 = from.charAt(1);
    int c2 = to.charAt(0),   r2 = to.charAt(1);
    return Math.abs(c2 - c1) == Math.abs(r2 - r1);
}

/**
 * pathClear checks squares in between from->to for rooks/bishops/queens. 
 * We'll do a naive approach.
 */
private boolean pathClear(BoardState board, String from, String to) {
    // skip if from==to
    if(from.equals(to)) return false;
    int c1=from.charAt(0), r1=from.charAt(1);
    int c2=to.charAt(0),   r2=to.charAt(1);

    int dc = Integer.compare(c2,c1); // 1,0,-1
    int dr = Integer.compare(r2,r1);
    int x = c1+dc, y = r1+dr;
    while(x!=c2 || y!=r2) {
        String sq = ""+ (char)x + (char)y;
        if(board.isOccupied(sq)) return false;
        x+=dc; y+=dr;
    }
    return true;
}


private boolean isInCheck(BoardState board, Color side) {
    String kingSquare = null;
    for (String sq : board.boardMap.keySet()) {
        PieceInfo pi = board.boardMap.get(sq);
        if (pi.color == side && pi.type == Piece.KING) {
            kingSquare = sq;
            break;
        }
    }
    if (kingSquare == null)
        return false;
    
    for (String sq : board.boardMap.keySet()) {
        PieceInfo enemy = board.boardMap.get(sq);
        if (enemy.color != side) {
            switch (enemy.type) {
                case KNIGHT:
                    if (isKnightMove(sq, kingSquare))
                        return true;
                    break;
                case PAWN:
                    if (isPawnAttacking(enemy.color, sq, kingSquare))
                        return true;
                    break;
                case KING:
                    if (isKingAdjacent(sq, kingSquare))
                        return true;
                    break;
                case ROOK:
                case BISHOP:
                case QUEEN:
                    if (isMovePatternLegal(board, sq, kingSquare, enemy.type, side, false) && pathClear(board, sq, kingSquare))
                        return true;
                    break;
                default:
                    break;
            }
        }
    }
    return false;
}

// Helper methods:
private boolean isKnightMove(String from, String to) {
    int c1 = from.charAt(0), r1 = from.charAt(1);
    int c2 = to.charAt(0),   r2 = to.charAt(1);
    int dc = Math.abs(c2 - c1), dr = Math.abs(r2 - r1);
    return (dc == 2 && dr == 1) || (dc == 1 && dr == 2);
}

private boolean isPawnAttacking(Color pawnColor, String from, String to) {
    int fileFrom = from.charAt(0);
    int rankFrom = from.charAt(1);
    int fileTo = to.charAt(0);
    int rankTo = to.charAt(1);
    int fileDiff = Math.abs(fileTo - fileFrom);
    int rankDiff = (pawnColor == Color.WHITE) ? rankTo - rankFrom : rankFrom - rankTo;
    return fileDiff == 1 && rankDiff == 1;
}

private boolean isKingAdjacent(String from, String to) {
    int c1 = from.charAt(0), r1 = from.charAt(1);
    int c2 = to.charAt(0),   r2 = to.charAt(1);
    return Math.abs(c2 - c1) <= 1 && Math.abs(r2 - r1) <= 1;
}


/**
 * isCheckmate: side is in check and no legal move can remove it.
 * We'll do a naive approach: find all squares of side, attempt all possible moves, see if any remove check.
 */
private boolean isCheckmate(BoardState board, Color side) {
    if(!isInCheck(board,side)) return false;
    // Try each piece, each possible square
    for(String sq: board.boardMap.keySet()) {
        PieceInfo pi = board.boardMap.get(sq);
        if(pi.color==side) {
            // generate possible squares in a naive manner
            for(String to: board.boardMap.keySet()) {
                // or squares off board
                if(!sq.equals(to)) {
                    if(isMovePatternLegal(board, sq, to, pi.type, side, true)) {
                        // check if occupant is friend or foe, etc.
                        // We'll do a partial apply
                        PieceInfo occupant = board.getPieceAt(to);
                        boolean friendThere = occupant!=null && occupant.color==side;
                        if(!friendThere) {
                            // try
                            PieceInfo savedFrom = pi;
                            PieceInfo savedTo   = occupant;
                            board.removePiece(sq);
                            board.removePiece(to);
                            pi.hasMoved=true;
                            board.boardMap.put(to, pi);

                            boolean stillCheck = isInCheck(board, side);

                            // revert
                            board.removePiece(to);
                            if(savedTo!=null) board.boardMap.put(to, savedTo);
                            board.boardMap.put(sq, savedFrom);

                            if(!stillCheck) return false; // we found a move
                        }
                    }
                }
            }
        }
    }
    return true;
}


Most functional generator file:
package uk.ac.kcl.in.nerosiegfried.chessdsl.generator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.generator.IFileSystemAccess2;

import uk.ac.kcl.in.nerosiegfried.chessdsl.chessDSL.*;
import uk.ac.kcl.in.nerosiegfried.chessdsl.validation.ChessDSLValidator.BoardState;
import uk.ac.kcl.in.nerosiegfried.chessdsl.validation.ChessDSLValidator.PieceInfo;

/**
 * isMovePatternLegal checks if path is blocked for Rooks, Bishops, Queens,
 * if Knights jump, etc. We'll do a simplified logic.
 */

public class ChessDSLGenerator extends AbstractGenerator {

    static class PieceInfo {
        public Color color; 
        public Piece type; 
        public boolean hasMoved;
        public PieceInfo(Color c, Piece t) {
            color = c; 
            type  = t; 
            hasMoved = false;
        }
    }

    static class BoardState {
        Map<String, PieceInfo> boardMap = new HashMap<>();

        public void initFreshBoard() {
            boardMap.clear();
            // White
            place("a1",Color.WHITE,Piece.ROOK); place("b1",Color.WHITE,Piece.KNIGHT);
            place("c1",Color.WHITE,Piece.BISHOP); place("d1",Color.WHITE,Piece.QUEEN);
            place("e1",Color.WHITE,Piece.KING);   place("f1",Color.WHITE,Piece.BISHOP);
            place("g1",Color.WHITE,Piece.KNIGHT); place("h1",Color.WHITE,Piece.ROOK);
            for(char c='a'; c<='h'; c++){
                place(c+"2",Color.WHITE,Piece.PAWN);
            }
            // Black
            place("a8",Color.BLACK,Piece.ROOK); place("b8",Color.BLACK,Piece.KNIGHT);
            place("c8",Color.BLACK,Piece.BISHOP); place("d8",Color.BLACK,Piece.QUEEN);
            place("e8",Color.BLACK,Piece.KING);   place("f8",Color.BLACK,Piece.BISHOP);
            place("g8",Color.BLACK,Piece.KNIGHT); place("h8",Color.BLACK,Piece.ROOK);
            for(char c='a'; c<='h'; c++){
                place(c+"7",Color.BLACK,Piece.PAWN);
            }
        }
        public void place(String sq, Color c, Piece p) {
            boardMap.put(sq, new PieceInfo(c,p));
        }
        public boolean isOccupied(String sq) { return boardMap.containsKey(sq); }
        public PieceInfo get(String sq)       { return boardMap.get(sq); }
        public void remove(String sq)         { boardMap.remove(sq); }
        public void movePiece(String from, String to) {
            PieceInfo pi = boardMap.remove(from);
            if(pi != null) {
                pi.hasMoved = true;
                boardMap.remove(to);
                boardMap.put(to, pi);
            }
        }
    }
    
    

    @Override
    public void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        if(resource == null || resource.getContents().isEmpty()) return;
        if(!(resource.getContents().get(0) instanceof Model)) return;

        Model model = (Model) resource.getContents().get(0);
        Game game = model.getGame();
        if(game == null) return;

        BoardState board = new BoardState();
        if(game.getInitial()!=null && game.getInitial().getPositions()!=null) {
            for(Placement pl : game.getInitial().getPositions().getPlacement()) {
                board.place(pl.getSquare().getSquare(),
                            pl.getPiece().getColor(),
                            pl.getPiece().getKind());
            }
        } else {
            board.initFreshBoard();
        }

        StringBuilder sb = new StringBuilder();
        sb.append("=== Chess Algebraic Notation ===\n");

        // NEW: Include the players (if any) after the game title
        sb.append("Game: ").append(game.getTitle());
        if(!game.getPlayers().isEmpty()) {
            sb.append(" (");
            for(int i=0; i<game.getPlayers().size(); i++){
                Player p = game.getPlayers().get(i);
                sb.append(p.getName()).append(" (").append(p.getColor()).append(")");
                if(i < game.getPlayers().size()-1) sb.append(" vs ");
            }
            sb.append(")");
        }
        sb.append("\n");

        int moveIndex = 1;
        for(MovePair mp : game.getMoves()) {
            boolean skipWhite = "...".equals(mp.getWhiteMove());
            sb.append(moveIndex).append(". ");

            if(skipWhite) {
                // e.g. "1. ... e5"
                if(mp.getBlackMove()!=null && mp.getBlackMove().getMove()!=null) {
                    DSLMove bmove = mp.getBlackMove().getMove();
                    String note = toAlgebraic(bmove, Color.BLACK, board);
                    applyMove(board, bmove, Color.BLACK);
                    sb.append("... ").append(note).append("\n");
                }
            } else {
                // White
                if(mp.getWhiteMove()!=null && mp.getWhiteMove().getMove()!=null) {
                    DSLMove wmove = mp.getWhiteMove().getMove();
                    String note = toAlgebraic(wmove, Color.WHITE, board);
                    applyMove(board, wmove, Color.WHITE);
                    sb.append(note).append(" ");
                }
                // Black
                if(mp.getBlackMove()!=null && mp.getBlackMove().getMove()!=null) {
                    DSLMove bmove = mp.getBlackMove().getMove();
                    String note = toAlgebraic(bmove, Color.BLACK, board);
                    applyMove(board, bmove, Color.BLACK);
                    sb.append(note).append(" ");
                }
                sb.append("\n");
            }
            moveIndex++;
        }

        // CHANGED: Render conclusion in a user-friendly manner, referencing 
        // any color/player in the result
        if(game.getConclusion() != null) {
            sb.append("Conclusion: ").append(renderConclusion(game.getConclusion())).append("\n");
        }

        // CHANGED: generate file with suffix
        fsa.generateFile(resource.getURI().lastSegment() + "_generated.txt", sb.toString());
    }

    // -------------------------------------------------------------------------
    // Convert DSLMove => algebraic notation
    // -------------------------------------------------------------------------
    private String toAlgebraic(DSLMove move, Color side, BoardState board) {
        List<Remark> remarks = getRemarks(move);

        if(move instanceof Move) {
            return convertBasic((Move) move, side, board, remarks);
        } else if(move instanceof Capture) {
            return convertCapture((Capture) move, side, board, remarks);
        } else if(move instanceof Castle) {
            return convertCastle((Castle) move, side, board, remarks);
        } else if(move instanceof EnPassant) {
            return convertEnPassant((EnPassant) move, side, board, remarks);
        } else if(move instanceof Promotion) {
            return convertPromotion((Promotion) move, side, board, remarks);
        } else if(move instanceof Dummy) {
            return "dummy";
        }
        return "";
    }

    // region Move Conversions
    private String convertBasic(Move mv, Color side, BoardState board, List<Remark> remarks) {
        Piece p = mv.getPiece();
        String from = mv.getFrom().getSquare();
        String to   = mv.getTo().getSquare();

        // 1) simulate => check or mate
        applyMove(board, mv, side);
        boolean isCheck = isInCheck(board, opposite(side));
        boolean isMate  = (isCheck && isCheckmate(board, opposite(side)));
        revertMove(board, mv, side, null);

        // 2) build notation
        String letter = (p==Piece.PAWN)? "" : pieceLetter(p);
        
        String disamb = disambiguate(board, from, to, side, p);
        
        String baseNotation = letter + disamb + to;

        // 3) combine
        String suffix = combineSuffixes(isCheck, isMate, remarks);
        return baseNotation + suffix;
    }

    private String convertCapture(Capture cap, Color side, BoardState board, List<Remark> remarks) {
        Move base = cap.getMove();
        Piece p   = base.getPiece();
        String from= base.getFrom().getSquare();
        String to  = base.getTo().getSquare();

        applyMove(board, cap, side);
        boolean isCheck = isInCheck(board, opposite(side));
        boolean isMate  = (isCheck && isCheckmate(board, opposite(side)));
        revertMove(board, cap, side, null);

        String letter = (p==Piece.PAWN)? from.substring(0,1) : pieceLetter(p);
        String disamb = disambiguate(board, from, to, side, p);
        
        String notation = letter + disamb + "x" + to;

        String suffix = combineSuffixes(isCheck, isMate, remarks);
        return notation + suffix;
    }

    private String convertCastle(Castle cs, Color side, BoardState board, List<Remark> remarks) {
        applyMove(board, cs, side);
        boolean isCheck = isInCheck(board, opposite(side));
        boolean isMate  = (isCheck && isCheckmate(board, opposite(side)));
        revertMove(board, cs, side, null);
        String base = cs.getSide() == "Kingside" ? "O-O" : "O-O-O";
        String suffix = combineSuffixes(isCheck, isMate, remarks);
        return base + suffix;
    }

    private String convertEnPassant(EnPassant ep, Color side, BoardState board, List<Remark> remarks) {
        Capture cp = ep.getCapture();
        Move base = cp.getMove();
        String from= base.getFrom().getSquare();
        String to  = base.getTo().getSquare();

        applyMove(board, ep, side);
        boolean isCheck = isInCheck(board, opposite(side));
        boolean isMate  = (isCheck && isCheckmate(board, opposite(side)));
        revertMove(board, ep, side, null);

        String fileFrom = from.substring(0,1);
        String baseNotation = fileFrom + "x" + to + " e.p.";
        String suffix = combineSuffixes(isCheck, isMate, remarks);
        return baseNotation + suffix;
    }

    private String convertPromotion(Promotion pm, Color side, BoardState board, List<Remark> remarks) {
        DSLMove b = pm.getMove();
        Move mv=null; boolean isCap=false;
        if(b instanceof Move) {
            mv=(Move)b;
        } else {
            mv=((Capture)b).getMove();
            isCap=true;
        }
        String from= mv.getFrom().getSquare();
        String to  = mv.getTo().getSquare();

        applyMove(board, pm, side);
        boolean isCheck = isInCheck(board, opposite(side));
        boolean isMate  = (isCheck && isCheckmate(board, opposite(side)));
        revertMove(board, pm, side, null);

        String pieceStr = pieceLetter(pm.getPiece());
        // If capturing and it's a pawn, we prefix the file
        String file = "";
        if(mv.getPiece()==Piece.PAWN && isCap) {
            file = from.substring(0,1);
        } else if(mv.getPiece()!=Piece.PAWN) {
            file = pieceLetter(mv.getPiece());
        }
        String captureSym = isCap? file + "x":"";
        String base = captureSym + to + "=" + pieceStr;

        String suffix = combineSuffixes(isCheck, isMate, remarks);
        return base + suffix;
    }
    // endregion

    // CHANGED: If the move is mate, skip the "Check" remark. 
    // If remarks contain "Checkmate", skip "Check" as well 
    private String combineSuffixes(boolean isCheck, boolean isMate, List<Remark> remarks) {
        StringBuilder sb = new StringBuilder();
        if(isMate) {
            sb.append("#");  // no plus
        } else if(isCheck) {
            sb.append("+");
        }

        boolean hasCheckmateRemark = remarks.contains(Remark.CHECKMATE);

        for(Remark r : remarks) {
            // skip the "Check" remark if there's also checkmate
            if(r == Remark.CHECK && (hasCheckmateRemark || isMate)) {
                continue;
            }
            sb.append(translateRemark(r));
        }
        return sb.toString();
    }

    private String translateRemark(Remark r) {
        switch(r) {
            case GOOD:       return "!";
            case BAD:        return "?";
            case EXCELLENT:  return "!!";
            case RISKY:      return "!?";
            case DUBIOUS:    return "?!";
            case CHECK:      return "+";  // only if we didn't skip it
            case CHECKMATE:  return "#";  // might produce double "#"
            default:         return "";
        }
    }

    // region Conclusion
    // CHANGED: Render conclusion with player references or color references
    private String renderConclusion(Conclusion c) {
        if(c.getResult()==null) return "";

        Result r = c.getResult();
        // if it's "draw"
        if("draw".equalsIgnoreCase(r.toString())) {
            return "1/2-1/2";
        }

        // if color=Black => "Black wins"
        if(r.getColor()!=null) {
            return r.getColor().toString() + " wins";
        }
        // if there's a player => e.g. "Alice (White) wins"
        if(r.getPlayer()!=null) {
            return r.getPlayer().getName() 
                   + " (" + r.getPlayer().getColor() + ") wins";
        }
        // fallback
        return r.toString();
    }
    // endregion

    // region Checking & simulation
    private void applyMove(BoardState b, DSLMove m, Color side) {
        if(m instanceof Move) {
            Move mo = (Move)m;
            b.movePiece(mo.getFrom().getSquare(), mo.getTo().getSquare());
        } else if(m instanceof Capture) {
            Move base = ((Capture)m).getMove();
            b.movePiece(base.getFrom().getSquare(), base.getTo().getSquare());
        } else if(m instanceof EnPassant) {
            EnPassant ep = (EnPassant)m;
            Move base = ep.getCapture().getMove();
            b.movePiece(base.getFrom().getSquare(), base.getTo().getSquare());
            b.remove(ep.getSquare().getSquare());
        } else if(m instanceof Promotion) {
            Promotion pm = (Promotion)m;
            DSLMove base = pm.getMove();
            Move mo=null; boolean isCap=false;
            if(base instanceof Move) mo=(Move)base;
            else { mo=((Capture)base).getMove(); isCap=true; }
            b.movePiece(mo.getFrom().getSquare(), mo.getTo().getSquare());
            b.remove(mo.getTo().getSquare());
            b.place(mo.getTo().getSquare(), side, pm.getPiece());
        } else if(m instanceof Castle) {
            Castle cs = (Castle)m;
            boolean kingside = true;
            if(side==Color.WHITE) {
                if(b.get("h1")!=null && b.get("h1").type==Piece.ROOK) kingside=true; else kingside=false;
                if(kingside) {
                    b.remove("e1"); b.remove("h1");
                    b.place("g1", Color.WHITE, Piece.KING);
                    b.place("f1", Color.WHITE, Piece.ROOK);
                } else {
                    b.remove("e1"); b.remove("a1");
                    b.place("c1", Color.WHITE, Piece.KING);
                    b.place("d1", Color.WHITE, Piece.ROOK);
                }
            } else {
                if(b.get("h8")!=null && b.get("h8").type==Piece.ROOK) kingside=true; else kingside=false;
                if(kingside) {
                    b.remove("e8"); b.remove("h8");
                    b.place("g8", Color.BLACK, Piece.KING);
                    b.place("f8", Color.BLACK, Piece.ROOK);
                } else {
                    b.remove("e8"); b.remove("a8");
                    b.place("c8", Color.BLACK, Piece.KING);
                    b.place("d8", Color.BLACK, Piece.ROOK);
                }
            }
        }
    }

    private void revertMove(BoardState b, DSLMove m, Color side, PieceInfo captured) {
        // We do nothing for demonstration
    }

    // minimal check & mate

    private boolean canMovePiece(BoardState board, String from, String to, PieceInfo pi) {
        // minimal movement check
        if(pi.type==Piece.KNIGHT) {
            return isKnightMove(from, to);
        } else if(pi.type==Piece.KING) {
            return isKingAdjacent(from, to);
        } else if(pi.type==Piece.ROOK) {
            if(!sameFileOrRank(from,to)) return false;
            return pathIsClear(board, from, to);
        } else if(pi.type==Piece.BISHOP) {
            if(!isDiagonal(from,to)) return false;
            return pathIsClear(board, from, to);
        } else if(pi.type==Piece.QUEEN) {
            if(isDiagonal(from,to) || sameFileOrRank(from,to)) {
                return pathIsClear(board, from, to);
            }
            return false;
        } else if(pi.type==Piece.PAWN) {
            // skip details
            return true;
        }
        return false;
    }

    private boolean canCaptureSquare(BoardState board, String from, String to, PieceInfo enemy) {
        switch(enemy.type) {
            case KNIGHT:
                return isKnightMove(from, to);
            case KING:
                return isKingAdjacent(from, to);
            case PAWN:
                return isPawnAttacking(enemy.color, from, to);
            case ROOK:
                if(!sameFileOrRank(from,to)) return false;
                return pathIsClear(board, from, to);
            case BISHOP:
                if(!isDiagonal(from,to)) return false;
                return pathIsClear(board, from, to);
            case QUEEN:
                if(isDiagonal(from,to) || sameFileOrRank(from,to)) {
                    return pathIsClear(board, from, to);
                }
                return false;
            default:
                return false;
        }
    }

    private String findKing(BoardState board, Color side) {
        for(String sq : board.boardMap.keySet()) {
            PieceInfo pi = board.boardMap.get(sq);
            if(pi.color==side && pi.type==Piece.KING) {
                return sq;
            }
        }
        return null;
    }





    private boolean pathIsClear(BoardState board, String from, String to) {
        // skip if from==to
        if(from.equals(to)) return false;
        int c1=from.charAt(0), r1=from.charAt(1);
        int c2=to.charAt(0),   r2=to.charAt(1);

        int dc = Integer.compare(c2,c1); // 1,0,-1
        int dr = Integer.compare(r2,r1);
        int x = c1+dc, y = r1+dr;
        while(x!=c2 || y!=r2) {
            String sq = ""+ (char)x + (char)y;
            if(board.isOccupied(sq)) return false;
            x+=dc; y+=dr;
        }
        return true;
    }

    private String disambiguate(BoardState board, String from, String to, Color side, Piece p) {
        // gather all squares that have a piece of the same type & color
        List<String> samePieces = new ArrayList<>();
        for(String sq : board.boardMap.keySet()) {
            PieceInfo pi = board.boardMap.get(sq);
            if(pi.type == p && pi.color == side) {
                // check if that piece can move to `to`
                if(isMovePatternLegal(board, sq, to, p, side, true) || isMovePatternLegal(board, sq, to, p, side, false)) {
                    samePieces.add(sq);
                }
            }
        }
        // if only 1 piece can go there => no disambiguation needed
        if(samePieces.size() <= 1) return "";
        
        // if more than 1 => figure out which is the actual from
        // if the user says from=“b1”, then you might do:
        if(!from.isEmpty()) {
            // from is e.g. "b1"
            String fromFile = from.substring(0,1); // “b”
            String fromRank = from.substring(1);   // “1”
            
            // see if at least two share the same file => disambiguate by file or rank
            boolean sameFile = false;
            boolean sameRank = false;
            for(String loc : samePieces) {
                if(!loc.equals(from)) {
                    // compare files/ranks
                    if(loc.charAt(0) == from.charAt(0)) sameFile = true;
                    if(loc.charAt(1) == from.charAt(1)) sameRank = true;
                }
            }
            // if sameFile => disambiguate by file if necessary, etc.
            // Simplest approach:
            if(!sameFile) {
                // that means the from-file is unique
                return fromFile;
            } else if(!sameRank) {
                // the from-rank is unique
                return fromRank;
            } else {
                // we have to return file+rank
                return from;
            }
        }
        return "";
    }

    /**
     * isMovePatternLegal checks if path is blocked for Rooks, Bishops, Queens,
     * if Knights jump, etc. We'll do a simplified logic.
     */
    private boolean isMovePatternLegal(BoardState board, String from, String to, Piece p, Color side, boolean isCapture) {
        // e.g. if it's a Knight => check L-shape
        if(p == Piece.KNIGHT) {
            int c1 = from.charAt(0), r1 = from.charAt(1);
            int c2 = to.charAt(0),   r2 = to.charAt(1);
            int dc = Math.abs(c2 - c1), dr = Math.abs(r2 - r1);
            return (dc==2 && dr==1) || (dc==1 && dr==2);
        } 
        else if(p == Piece.KING) {
            // must be 1 square in any direction
            int c1 = from.charAt(0), r1 = from.charAt(1);
            int c2 = to.charAt(0),   r2 = to.charAt(1);
            return (Math.abs(c2 - c1)<=1) && (Math.abs(r2 - r1)<=1);
        }
        else if(p == Piece.ROOK) {
            if(!sameFileOrRank(from,to)) return false;
            // ensure no blocking squares
            return pathClear(board, from, to);
        }
        else if(p == Piece.BISHOP) {
            if(!isDiagonal(from,to)) return false;
            return pathClear(board, from, to);
        }
        else if(p == Piece.QUEEN) {
            if(isDiagonal(from,to) || sameFileOrRank(from,to)) {
                return pathClear(board, from, to);
            }
            return false;
        }
        else if(p == Piece.PAWN) {
        	int fFrom = from.charAt(0) - 'a';
            int rFrom = from.charAt(1) - '0';
            int fTo = to.charAt(0) - 'a';
            int rTo = to.charAt(1) - '0';
            int fileDiff = Math.abs(fTo - fFrom);
            int rankDiff = (side == Color.WHITE) ? rTo - rFrom : rFrom - rTo;
            if(isCapture) {
                // Pawn capture: must move diagonally one square
                return fileDiff == 1 && rankDiff == 1;
            } else {
                // Pawn forward move: file must be same
                if(fileDiff != 0) return false;
                if(rankDiff == 1) return true;
                if(rankDiff == 2 && ((side == Color.WHITE && rFrom == 2) || (side == Color.BLACK && rFrom == 7))) {
                    char intermediate = (side == Color.WHITE) ? (char)(rFrom + 1 + '0') : (char)(rFrom - 1 + '0');
                    String interSq = "" + from.charAt(0) + intermediate;
                    return !board.isOccupied(interSq);
                }
                return false;
            }
        }
        return true;
    }

    private boolean sameFileOrRank(String from, String to) {
        return (from.charAt(0)==to.charAt(0) || from.charAt(1)==to.charAt(1));
    }

    private boolean isDiagonal(String from, String to) {
        int c1 = from.charAt(0), r1 = from.charAt(1);
        int c2 = to.charAt(0),   r2 = to.charAt(1);
        return Math.abs(c2 - c1) == Math.abs(r2 - r1);
    }

    /**
     * pathClear checks squares in between from->to for rooks/bishops/queens. 
     * We'll do a naive approach.
     */
    private boolean pathClear(BoardState board, String from, String to) {
        // skip if from==to
        if(from.equals(to)) return false;
        int c1=from.charAt(0), r1=from.charAt(1);
        int c2=to.charAt(0),   r2=to.charAt(1);

        int dc = Integer.compare(c2,c1); // 1,0,-1
        int dr = Integer.compare(r2,r1);
        int x = c1+dc, y = r1+dr;
        while(x!=c2 || y!=r2) {
            String sq = ""+ (char)x + (char)y;
            if(board.isOccupied(sq)) return false;
            x+=dc; y+=dr;
        }
        return true;
    }

    
    private boolean isInCheck(BoardState board, Color side) {
        String kingSquare = null;
        for (String sq : board.boardMap.keySet()) {
            PieceInfo pi = board.boardMap.get(sq);
            if (pi.color == side && pi.type == Piece.KING) {
                kingSquare = sq;
                break;
            }
        }
        if (kingSquare == null)
            return false;
        
        for (String sq : board.boardMap.keySet()) {
            PieceInfo enemy = board.boardMap.get(sq);
            if (enemy.color != side) {
                switch (enemy.type) {
                    case KNIGHT:
                        if (isKnightMove(sq, kingSquare))
                            return true;
                        break;
                    case PAWN:
                        if (isPawnAttacking(enemy.color, sq, kingSquare))
                            return true;
                        break;
                    case KING:
                        if (isKingAdjacent(sq, kingSquare))
                            return true;
                        break;
                    case ROOK:
                    case BISHOP:
                    case QUEEN:
                        if (isMovePatternLegal(board, sq, kingSquare, enemy.type, side, false) && pathClear(board, sq, kingSquare))
                            return true;
                        break;
                    default:
                        break;
                }
            }
        }
        return false;
    }

    // Helper methods:
    private boolean isKnightMove(String from, String to) {
        int c1 = from.charAt(0), r1 = from.charAt(1);
        int c2 = to.charAt(0),   r2 = to.charAt(1);
        int dc = Math.abs(c2 - c1), dr = Math.abs(r2 - r1);
        return (dc == 2 && dr == 1) || (dc == 1 && dr == 2);
    }

    private boolean isPawnAttacking(Color pawnColor, String from, String to) {
        int fileFrom = from.charAt(0);
        int rankFrom = from.charAt(1);
        int fileTo = to.charAt(0);
        int rankTo = to.charAt(1);
        int fileDiff = Math.abs(fileTo - fileFrom);
        int rankDiff = (pawnColor == Color.WHITE) ? rankTo - rankFrom : rankFrom - rankTo;
        return fileDiff == 1 && rankDiff == 1;
    }

    private boolean isKingAdjacent(String from, String to) {
        int c1 = from.charAt(0), r1 = from.charAt(1);
        int c2 = to.charAt(0),   r2 = to.charAt(1);
        return Math.abs(c2 - c1) <= 1 && Math.abs(r2 - r1) <= 1;
    }


    /**
     * isCheckmate: side is in check and no legal move can remove it.
     * We'll do a naive approach: find all squares of side, attempt all possible moves, see if any remove check.
     */
    private boolean isCheckmate(BoardState board, Color side) {
        if(!isInCheck(board,side)) return false;
        // Try each piece, each possible square
        for(String sq: board.boardMap.keySet()) {
            PieceInfo pi = board.boardMap.get(sq);
            if(pi.color==side) {
                // generate possible squares in a naive manner
                for(String to: board.boardMap.keySet()) {
                    // or squares off board
                    if(!sq.equals(to)) {
                        if(isMovePatternLegal(board, sq, to, pi.type, side, true)) {
                            // check if occupant is friend or foe, etc.
                            // We'll do a partial apply
                            PieceInfo occupant = board.get(to);
                            boolean friendThere = occupant!=null && occupant.color==side;
                            if(!friendThere) {
                                // try
                                PieceInfo savedFrom = pi;
                                PieceInfo savedTo   = occupant;
                                board.remove(sq);
                                board.remove(to);
                                pi.hasMoved=true;
                                board.boardMap.put(to, pi);

                                boolean stillCheck = isInCheck(board, side);

                                // revert
                                board.remove(to);
                                if(savedTo!=null) board.boardMap.put(to, savedTo);
                                board.boardMap.put(sq, savedFrom);

                                if(!stillCheck) return false; // we found a move
                            }
                        }
                    }
                }
            }
        }
        return true;
    }

    // -------------------------------------------------------------------------
    // Helpers
    // -------------------------------------------------------------------------
    private List<Remark> getRemarks(DSLMove move) {
        if(move.eContainer() instanceof AnyMove) {
            AnyMove a = (AnyMove) move.eContainer();
            return a.getRemarks();
        }
        return new ArrayList<>();
    }

    private Color opposite(Color c) {
        return (c==Color.WHITE)? Color.BLACK : Color.WHITE;
    }

    private String pieceLetter(Piece p) {
        switch(p) {
            case KING:   return "K";
            case QUEEN:  return "Q";
            case ROOK:   return "R";
            case BISHOP: return "B";
            case KNIGHT: return "N";
            default:     return "";
        }
    }
}


Saving you in case (I should really learn to use git)
package uk.ac.kcl.in.nerosiegfried.chessdsl.generator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.generator.IFileSystemAccess2;

import uk.ac.kcl.in.nerosiegfried.chessdsl.chessDSL.*;
import uk.ac.kcl.in.nerosiegfried.chessdsl.validation.ChessDSLValidator.BoardState;
import uk.ac.kcl.in.nerosiegfried.chessdsl.validation.ChessDSLValidator.PieceInfo;

public class ChessDSLGenerator extends AbstractGenerator {

    // --- Nested classes for board modeling ---

    static class PieceInfo {
        public Color color;
        public Piece type;
        public boolean hasMoved;

        public PieceInfo(Color c, Piece t) {
            color = c;
            type = t;
            hasMoved = false;
        }
    }

    static class BoardState {
        Map<String, PieceInfo> boardMap = new HashMap<>();

        public void initFreshBoard() {
            boardMap.clear();
            // White major pieces
            place("a1", Color.WHITE, Piece.ROOK);
            place("b1", Color.WHITE, Piece.KNIGHT);
            place("c1", Color.WHITE, Piece.BISHOP);
            place("d1", Color.WHITE, Piece.QUEEN);
            place("e1", Color.WHITE, Piece.KING);
            place("f1", Color.WHITE, Piece.BISHOP);
            place("g1", Color.WHITE, Piece.KNIGHT);
            place("h1", Color.WHITE, Piece.ROOK);
            // White pawns
            for (char c = 'a'; c <= 'h'; c++) {
                place(c + "2", Color.WHITE, Piece.PAWN);
            }
            // Black major pieces
            place("a8", Color.BLACK, Piece.ROOK);
            place("b8", Color.BLACK, Piece.KNIGHT);
            place("c8", Color.BLACK, Piece.BISHOP);
            place("d8", Color.BLACK, Piece.QUEEN);
            place("e8", Color.BLACK, Piece.KING);
            place("f8", Color.BLACK, Piece.BISHOP);
            place("g8", Color.BLACK, Piece.KNIGHT);
            place("h8", Color.BLACK, Piece.ROOK);
            // Black pawns
            for (char c = 'a'; c <= 'h'; c++) {
                place(c + "7", Color.BLACK, Piece.PAWN);
            }
        }

        public void place(String sq, Color c, Piece p) {
            boardMap.put(sq, new PieceInfo(c, p));
        }

        public boolean isOccupied(String sq) {
            return boardMap.containsKey(sq);
        }

        public PieceInfo get(String sq) {
            return boardMap.get(sq);
        }

        public void remove(String sq) {
            boardMap.remove(sq);
        }

        public void movePiece(String from, String to) {
            PieceInfo pi = boardMap.remove(from);
            if (pi != null) {
                pi.hasMoved = true;
                boardMap.remove(to);
                boardMap.put(to, pi);
            }
        }

        /**
         * Clone the board state (a shallow clone of the piece info is sufficient for our simulation).
         */
        public BoardState cloneBoard() {
            BoardState copy = new BoardState();
            for (String sq : boardMap.keySet()) {
                PieceInfo pi = boardMap.get(sq);
                PieceInfo copyPi = new PieceInfo(pi.color, pi.type);
                copyPi.hasMoved = pi.hasMoved;
                copy.boardMap.put(sq, copyPi);
            }
            return copy;
        }
    }

    // --- Helper Methods for Move Validation and Conversion ---

    private boolean sameFileOrRank(String from, String to) {
        return (from.charAt(0) == to.charAt(0)) || (from.charAt(1) == to.charAt(1));
    }

    private boolean isDiagonal(String from, String to) {
        int c1 = from.charAt(0), r1 = from.charAt(1);
        int c2 = to.charAt(0), r2 = to.charAt(1);
        return Math.abs(c2 - c1) == Math.abs(r2 - r1);
    }

    private boolean pathClear(BoardState board, String from, String to) {
        if (from.equals(to))
            return false;
        int c1 = from.charAt(0), r1 = from.charAt(1);
        int c2 = to.charAt(0), r2 = to.charAt(1);
        int dc = Integer.compare(c2, c1);
        int dr = Integer.compare(r2, r1);
        int x = c1 + dc, y = r1 + dr;
        while (x != c2 || y != r2) {
            String sq = "" + (char) x + (char) y;
            if (board.isOccupied(sq))
                return false;
            x += dc;
            y += dr;
        }
        return true;
    }

    private boolean isMovePatternLegal(BoardState board, String from, String to, Piece p, Color side, boolean isCapture) {
        if (p == Piece.KNIGHT) {
            int c1 = from.charAt(0), r1 = from.charAt(1);
            int c2 = to.charAt(0), r2 = to.charAt(1);
            int dc = Math.abs(c2 - c1), dr = Math.abs(r2 - r1);
            return (dc == 2 && dr == 1) || (dc == 1 && dr == 2);
        } else if (p == Piece.KING) {
            int c1 = from.charAt(0), r1 = from.charAt(1);
            int c2 = to.charAt(0), r2 = to.charAt(1);
            return (Math.abs(c2 - c1) <= 1) && (Math.abs(r2 - r1) <= 1);
        } else if (p == Piece.ROOK) {
            if (!sameFileOrRank(from, to))
                return false;
            return pathClear(board, from, to);
        } else if (p == Piece.BISHOP) {
            if (!isDiagonal(from, to))
                return false;
            return pathClear(board, from, to);
        } else if (p == Piece.QUEEN) {
            if (isDiagonal(from, to) || sameFileOrRank(from, to)) {
                return pathClear(board, from, to);
            }
            return false;
        } else if (p == Piece.PAWN) {
            int fFrom = from.charAt(0) - 'a';
            int rFrom = from.charAt(1) - '0';
            int fTo = to.charAt(0) - 'a';
            int rTo = to.charAt(1) - '0';
            int fileDiff = Math.abs(fTo - fFrom);
            int rankDiff = (side == Color.WHITE) ? rTo - rFrom : rFrom - rTo;
            if (isCapture) {
                return fileDiff == 1 && rankDiff == 1;
            } else {
                if (fileDiff != 0)
                    return false;
                if (rankDiff == 1)
                    return true;
                if (rankDiff == 2 && ((side == Color.WHITE && rFrom == 2) || (side == Color.BLACK && rFrom == 7))) {
                    char intermediate = (side == Color.WHITE)
                            ? (char) ((rFrom + 1) + '0')
                            : (char) ((rFrom - 1) + '0');
                    String interSq = "" + from.charAt(0) + intermediate;
                    return !board.isOccupied(interSq);
                }
                return false;
            }
        }
        return true;
    }

    // --- Methods for checking check and checkmate ---

    private boolean isKnightMove(String from, String to) {
        int c1 = from.charAt(0), r1 = from.charAt(1);
        int c2 = to.charAt(0), r2 = to.charAt(1);
        int dc = Math.abs(c2 - c1), dr = Math.abs(r2 - r1);
        return (dc == 2 && dr == 1) || (dc == 1 && dr == 2);
    }

    private boolean isKingAdjacent(String from, String to) {
        int c1 = from.charAt(0), r1 = from.charAt(1);
        int c2 = to.charAt(0), r2 = to.charAt(1);
        return Math.abs(c2 - c1) <= 1 && Math.abs(r2 - r1) <= 1;
    }

    private boolean isPawnAttacking(Color pawnColor, String from, String to) {
        int fileFrom = from.charAt(0);
        int rankFrom = from.charAt(1);
        int fileTo = to.charAt(0);
        int rankTo = to.charAt(1);
        int fileDiff = Math.abs(fileTo - fileFrom);
        int rankDiff = (pawnColor == Color.WHITE) ? rankTo - rankFrom : rankFrom - rankTo;
        return fileDiff == 1 && rankDiff == 1;
    }

    private boolean isInCheck(BoardState board, Color side) {
        String kingSquare = null;
        for (String sq : board.boardMap.keySet()) {
            PieceInfo pi = board.boardMap.get(sq);
            if (pi.color == side && pi.type == Piece.KING) {
                kingSquare = sq;
                break;
            }
        }
        if (kingSquare == null)
            return false;
        return anyEnemyCanCapture(board, side, kingSquare);
    }

    private boolean anyEnemyCanCapture(BoardState board, Color side, String kingSq) {
        for (String sq : board.boardMap.keySet()) {
            PieceInfo enemy = board.boardMap.get(sq);
            if (enemy.color != side) {
                if (enemy.type == Piece.KNIGHT) {
                    if (isKnightMove(sq, kingSq))
                        return true;
                } else if (enemy.type == Piece.KING) {
                    if (isKingAdjacent(sq, kingSq))
                        return true;
                } else if (enemy.type == Piece.PAWN) {
                    if (isPawnAttacking(enemy.color, sq, kingSq))
                        return true;
                } else {
                    if (isMovePatternLegal(board, sq, kingSq, enemy.type, side, false)
                            && pathClear(board, sq, kingSq))
                        return true;
                }
            }
        }
        return false;
    }

    private boolean isCheckmate(BoardState board, Color side) {
        if (!isInCheck(board, side))
            return false;
        for (String sq : board.boardMap.keySet()) {
            PieceInfo pi = board.boardMap.get(sq);
            if (pi.color == side) {
                for (String to : board.boardMap.keySet()) {
                    if (!sq.equals(to)) {
                        if (isMovePatternLegal(board, sq, to, pi.type, side, true)) {
                            PieceInfo occupant = board.get(sq);
                            // Use board.getPieceAt for clarity:
                            PieceInfo existing = board.get(to);
                            if (existing == null || existing.color != side) {
                                BoardState sim = board.cloneBoard();
                                sim.remove(sq);
                                sim.remove(to);
                                pi.hasMoved = true;
                                sim.boardMap.put(to, pi);
                                if (!isInCheck(sim, side)) {
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
        }
        return true;
    }

    // --- Disambiguation method ---
    private String disambiguate(BoardState board, String from, String to, Color side, Piece p) {
        List<String> samePieces = new ArrayList<>();
        for (String sq : board.boardMap.keySet()) {
            PieceInfo pi = board.boardMap.get(sq);
            if (pi.type == p && pi.color == side) {
                if (isMovePatternLegal(board, sq, to, p, side, true) ||
                    isMovePatternLegal(board, sq, to, p, side, false)) {
                    samePieces.add(sq);
                }
            }
        }
        if (samePieces.size() <= 1)
            return "";
        if (!from.isEmpty()) {
            String fromFile = from.substring(0, 1);
            String fromRank = from.substring(1);
            boolean sameFile = false;
            boolean sameRank = false;
            for (String loc : samePieces) {
                if (!loc.equals(from)) {
                    if (loc.charAt(0) == from.charAt(0))
                        sameFile = true;
                    if (loc.charAt(1) == from.charAt(1))
                        sameRank = true;
                }
            }
            if (!sameFile)
                return fromFile;
            else if (!sameRank)
                return fromRank;
            else
                return from;
        }
        return "";
    }

    // --- Methods for converting DSLMove into algebraic notation ---
    
    private List<Remark> getRemarks(DSLMove move) {
        if (move.eContainer() instanceof AnyMove) {
            AnyMove a = (AnyMove) move.eContainer();
            return a.getRemarks();
        }
        return new ArrayList<>();
    }

    private String pieceLetter(Piece p) {
        switch (p) {
            case KING:
                return "K";
            case QUEEN:
                return "Q";
            case ROOK:
                return "R";
            case BISHOP:
                return "B";
            case KNIGHT:
                return "N";
            default:
                return "";
        }
    }


    // --- Conversion of moves ---
    private String toAlgebraic(DSLMove move, Color side, BoardState board) {
        List<Remark> remarks = getRemarks(move);
        if (move instanceof Move) {
            return convertBasic((Move) move, side, board, remarks);
        } else if (move instanceof Capture) {
            return convertCapture((Capture) move, side, board, remarks);
        } else if (move instanceof Castle) {
            return convertCastle((Castle) move, side, board, remarks);
        } else if (move instanceof EnPassant) {
            return convertEnPassant((EnPassant) move, side, board, remarks);
        } else if (move instanceof Promotion) {
            return convertPromotion((Promotion) move, side, board, remarks);
        } else if (move instanceof Dummy) {
            return "dummy";
        }
        return "";
    }

    private String convertBasic(Move mv, Color side, BoardState board, List<Remark> remarks) {
        Piece p = mv.getPiece();
        String from = mv.getFrom().getSquare();
        String to = mv.getTo().getSquare();
        // Clone board for simulation so that the original remains intact for disambiguation
        BoardState simBoard = board.cloneBoard();
        String disamb = disambiguate(simBoard, from, to, side, p);
        applyMove(simBoard, mv, side);
        boolean isCheck = isInCheck(simBoard, opposite(side));
        boolean isMate = isCheck && isCheckmate(simBoard, opposite(side));
        String letter = (p == Piece.PAWN) ? "" : pieceLetter(p);
        String baseNotation = letter + disamb + to;
        String suffix = combineSuffixes(isCheck, isMate, remarks);
        return baseNotation + suffix;
    }

    private String convertCapture(Capture cap, Color side, BoardState board, List<Remark> remarks) {
        Move base = cap.getMove();
        Piece p = base.getPiece();
        String from = base.getFrom().getSquare();
        String to = base.getTo().getSquare();
        BoardState simBoard = board.cloneBoard();
        String disamb = disambiguate(simBoard, from, to, side, p);
        applyMove(simBoard, cap, side);
        boolean isCheck = isInCheck(simBoard, opposite(side));
        boolean isMate = isCheck && isCheckmate(simBoard, opposite(side));
        String letter = (p == Piece.PAWN) ? from.substring(0, 1) : pieceLetter(p);
        String notation = letter + disamb + "x" + to;
        String suffix = combineSuffixes(isCheck, isMate, remarks);
        return notation + suffix;
    }

    private String convertCastle(Castle cs, Color side, BoardState board, List<Remark> remarks) {
        BoardState simBoard = board.cloneBoard();
        applyMove(simBoard, cs, side);
        boolean isCheck = isInCheck(simBoard, opposite(side));
        boolean isMate = isCheck && isCheckmate(simBoard, opposite(side));
        String base = cs.getSide().equals("Kingside") ? "O-O" : "O-O-O";
        String suffix = combineSuffixes(isCheck, isMate, remarks);
        return base + suffix;
    }

    private String convertEnPassant(EnPassant ep, Color side, BoardState board, List<Remark> remarks) {
        Capture cp = ep.getCapture();
        Move base = cp.getMove();
        String from = base.getFrom().getSquare();
        String to = base.getTo().getSquare();
        BoardState simBoard = board.cloneBoard();
        applyMove(simBoard, ep, side);
        boolean isCheck = isInCheck(simBoard, opposite(side));
        boolean isMate = isCheck && isCheckmate(simBoard, opposite(side));
        String fileFrom = from.substring(0, 1);
        String baseNotation = fileFrom + "x" + to + " e.p.";
        String suffix = combineSuffixes(isCheck, isMate, remarks);
        return baseNotation + suffix;
    }

    private String convertPromotion(Promotion pm, Color side, BoardState board, List<Remark> remarks) {
        DSLMove inner = pm.getMove();
        Move mv = null;
        boolean isCap = false;
        if (inner instanceof Move) {
            mv = (Move) inner;
        } else {
            mv = ((Capture) inner).getMove();
            isCap = true;
        }
        String from = mv.getFrom().getSquare();
        String to = mv.getTo().getSquare();
        BoardState simBoard = board.cloneBoard();
        applyMove(simBoard, pm, side);
        boolean isCheck = isInCheck(simBoard, opposite(side));
        boolean isMate = isCheck && isCheckmate(simBoard, opposite(side));
        String pieceStr = pieceLetter(pm.getPiece());
        String file = "";
        if (mv.getPiece() == Piece.PAWN && isCap) {
            file = from.substring(0, 1);
        } else if (mv.getPiece() != Piece.PAWN) {
            file = pieceLetter(mv.getPiece());
        }
        String captureSym = isCap ? file + "x" : "";
        String baseNotation = captureSym + to + "=" + pieceStr;
        String suffix = combineSuffixes(isCheck, isMate, remarks);
        return baseNotation + suffix;
    }

    // --- Combining suffixes and remark translation ---

    private String combineSuffixes(boolean isCheck, boolean isMate, List<Remark> remarks) {
        StringBuilder sb = new StringBuilder();
        if (isMate) {
            sb.append("#");
        } else if (isCheck) {
            sb.append("+");
        }
        boolean hasCheckmateRemark = remarks.contains(Remark.CHECKMATE);
        for (Remark r : remarks) {
            if (r == Remark.CHECK && (hasCheckmateRemark || isMate)) {
                continue;
            }
            sb.append(translateRemark(r));
        }
        return sb.toString();
    }

    private String translateRemark(Remark r) {
        switch (r) {
            case GOOD:
                return "!";
            case BAD:
                return "?";
            case EXCELLENT:
                return "!!";
            case RISKY:
                return "!?";
            case DUBIOUS:
                return "?!";
            case CHECK:
                return "+";
            case CHECKMATE:
                return "#";
            default:
                return "";
        }
    }
    
    private Color opposite(Color c) {
        return c==Color.WHITE? Color.BLACK: Color.WHITE;
    }
    // --- Conclusion Rendering ---

    private String renderConclusion(Conclusion c) {
        if (c.getResult() == null)
            return "";
        Result r = c.getResult();
        if ("draw".equalsIgnoreCase(r.toString())) {
            return "1/2-1/2";
        }
        if (r.getPlayer() != null) {
            return r.getPlayer().getName() + " (" + r.getPlayer().getColor() + ") wins";
        }
        if (r.getColor() != null) {
            return r.getColor().toString() + " wins";
        }
        return r.toString();
    }

    // --- Applying and (stub) Reverting Moves ---

    private void applyMove(BoardState b, DSLMove m, Color side) {
        if (m instanceof Move) {
            Move mo = (Move) m;
            b.movePiece(mo.getFrom().getSquare(), mo.getTo().getSquare());
        } else if (m instanceof Capture) {
            Move base = ((Capture) m).getMove();
            b.movePiece(base.getFrom().getSquare(), base.getTo().getSquare());
        } else if (m instanceof EnPassant) {
            EnPassant ep = (EnPassant) m;
            Move base = ep.getCapture().getMove();
            b.movePiece(base.getFrom().getSquare(), base.getTo().getSquare());
            b.remove(ep.getSquare().getSquare());
        } else if (m instanceof Promotion) {
            Promotion pm = (Promotion) m;
            DSLMove base = pm.getMove();
            Move mo = (base instanceof Move) ? (Move) base : ((Capture) base).getMove();
            b.movePiece(mo.getFrom().getSquare(), mo.getTo().getSquare());
            b.remove(mo.getTo().getSquare());
            b.place(mo.getTo().getSquare(), side, pm.getPiece());
        } else if (m instanceof Castle) {
            Castle cs = (Castle) m;
            boolean kingside = "Kingside".equals(cs.getSide());
            if (side == Color.WHITE) {
                if (kingside) {
                    b.remove("e1");
                    b.remove("h1");
                    b.place("g1", Color.WHITE, Piece.KING);
                    b.place("f1", Color.WHITE, Piece.ROOK);
                } else {
                    b.remove("e1");
                    b.remove("a1");
                    b.place("c1", Color.WHITE, Piece.KING);
                    b.place("d1", Color.WHITE, Piece.ROOK);
                }
            } else {
                if (kingside) {
                    b.remove("e8");
                    b.remove("h8");
                    b.place("g8", Color.BLACK, Piece.KING);
                    b.place("f8", Color.BLACK, Piece.ROOK);
                } else {
                    b.remove("e8");
                    b.remove("a8");
                    b.place("c8", Color.BLACK, Piece.KING);
                    b.place("d8", Color.BLACK, Piece.ROOK);
                }
            }
        }
    }

    private void revertMove(BoardState b, DSLMove m, Color side, PieceInfo captured) {
        // Not implemented for demonstration.
    }
    @Override
    public void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        if(resource == null || resource.getContents().isEmpty()) return;
        if(!(resource.getContents().get(0) instanceof Model)) return;

        Model model = (Model) resource.getContents().get(0);
        Game game = model.getGame();
        if(game == null) return;

        BoardState board = new BoardState();
        if(game.getInitial()!=null && game.getInitial().getPositions()!=null) {
            for(Placement pl : game.getInitial().getPositions().getPlacement()) {
                board.place(pl.getSquare().getSquare(),
                            pl.getPiece().getColor(),
                            pl.getPiece().getKind());
            }
        } else {
            board.initFreshBoard();
        }

        StringBuilder sb = new StringBuilder();
        sb.append("=== Chess Algebraic Notation ===\n");

        // NEW: Include the players (if any) after the game title
        sb.append("Game: ").append(game.getTitle());
        if(!game.getPlayers().isEmpty()) {
            sb.append(" (");
            for(int i=0; i<game.getPlayers().size(); i++){
                Player p = game.getPlayers().get(i);
                sb.append(p.getName()).append(" (").append(p.getColor()).append(")");
                if(i < game.getPlayers().size()-1) sb.append(" vs ");
            }
            sb.append(")");
        }
        sb.append("\n");

        int moveIndex = 1;
        for(MovePair mp : game.getMoves()) {
            boolean skipWhite = "...".equals(mp.getWhiteMove());
            sb.append(moveIndex).append(". ");

            if(skipWhite) {
                // e.g. "1. ... e5"
                if(mp.getBlackMove()!=null && mp.getBlackMove().getMove()!=null) {
                    DSLMove bmove = mp.getBlackMove().getMove();
                    String note = toAlgebraic(bmove, Color.BLACK, board);
                    applyMove(board, bmove, Color.BLACK);
                    sb.append("... ").append(note).append("\n");
                }
            } else {
                // White
                if(mp.getWhiteMove()!=null && mp.getWhiteMove().getMove()!=null) {
                    DSLMove wmove = mp.getWhiteMove().getMove();
                    String note = toAlgebraic(wmove, Color.WHITE, board);
                    applyMove(board, wmove, Color.WHITE);
                    sb.append(note).append(" ");
                }
                // Black
                if(mp.getBlackMove()!=null && mp.getBlackMove().getMove()!=null) {
                    DSLMove bmove = mp.getBlackMove().getMove();
                    String note = toAlgebraic(bmove, Color.BLACK, board);
                    applyMove(board, bmove, Color.BLACK);
                    sb.append(note).append(" ");
                }
                sb.append("\n");
            }
            moveIndex++;
        }

        // CHANGED: Render conclusion in a user-friendly manner, referencing 
        // any color/player in the result
        if(game.getConclusion() != null) {
            sb.append("Conclusion: ").append(renderConclusion(game.getConclusion())).append("\n");
        }

        // CHANGED: generate file with suffix
        fsa.generateFile(resource.getURI().lastSegment() + "_generated.txt", sb.toString());
    }
}
